(() => {
var exports = {};
exports.id = 3611;
exports.ids = [3611];
exports.modules = {

/***/ 2967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./terraform/additional-sidebar-resources.json": 62310
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 2967;

/***/ }),

/***/ 33666:
/***/ ((module) => {

"use strict";
module.exports = require("@vercel/fetch");

/***/ }),

/***/ 59003:
/***/ ((module) => {

"use strict";
module.exports = require("classnames");

/***/ }),

/***/ 71239:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 48010:
/***/ ((module) => {

"use strict";
module.exports = require("http-status-codes");

/***/ }),

/***/ 56734:
/***/ ((module) => {

"use strict";
module.exports = require("js-cookie");

/***/ }),

/***/ 3280:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context.js");

/***/ }),

/***/ 92796:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/head-manager-context.js");

/***/ }),

/***/ 34014:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/i18n/normalize-locale-path.js");

/***/ }),

/***/ 78524:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/is-plain-object.js");

/***/ }),

/***/ 78020:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/mitt.js");

/***/ }),

/***/ 64406:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/page-path/denormalize-page-path.js");

/***/ }),

/***/ 24964:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router-context.js");

/***/ }),

/***/ 11751:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix.js");

/***/ }),

/***/ 46220:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/compare-states.js");

/***/ }),

/***/ 10299:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/format-next-pathname-info.js");

/***/ }),

/***/ 23938:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/format-url.js");

/***/ }),

/***/ 29565:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/get-asset-path-from-route.js");

/***/ }),

/***/ 35789:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/get-next-pathname-info.js");

/***/ }),

/***/ 1897:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot.js");

/***/ }),

/***/ 1428:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-dynamic.js");

/***/ }),

/***/ 28854:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path.js");

/***/ }),

/***/ 91292:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-relative-url.js");

/***/ }),

/***/ 34567:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/path-has-prefix.js");

/***/ }),

/***/ 80979:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/querystring.js");

/***/ }),

/***/ 93297:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash.js");

/***/ }),

/***/ 36052:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/resolve-rewrites.js");

/***/ }),

/***/ 84226:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/route-matcher.js");

/***/ }),

/***/ 95052:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/route-regex.js");

/***/ }),

/***/ 59232:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/utils.js");

/***/ }),

/***/ 71853:
/***/ ((module) => {

"use strict";
module.exports = require("next/router");

/***/ }),

/***/ 16689:
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ 66405:
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ 20997:
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-runtime");

/***/ }),

/***/ 73673:
/***/ ((module) => {

"use strict";
module.exports = require("slugify");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 22318:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ tutorialsMapHandler),
  "generateTutorialMap": () => (/* binding */ generateTutorialMap)
});

// EXTERNAL MODULE: external "http-status-codes"
var external_http_status_codes_ = __webpack_require__(48010);
;// CONCATENATED MODULE: ./src/lib/learn-client/types.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ var ProductOption;
(function(ProductOption) {
    ProductOption["boundary"] = "boundary";
    ProductOption["consul"] = "consul";
    ProductOption["nomad"] = "nomad";
    ProductOption["packer"] = "packer";
    ProductOption["terraform"] = "terraform";
    ProductOption["vagrant"] = "vagrant";
    ProductOption["vault"] = "vault";
    ProductOption["waypoint"] = "waypoint";
})(ProductOption || (ProductOption = {}));
var SectionOption;
(function(SectionOption) {
    SectionOption["well-architected-framework"] = "well-architected-framework";
    SectionOption["onboarding"] = "onboarding";
})(SectionOption || (SectionOption = {}));
var EditionOption;
(function(EditionOption) {
    EditionOption["openSource"] = "open_source";
    EditionOption["enterprise"] = "enterprise";
    EditionOption["hcp"] = "hcp";
    EditionOption["tfcStandard"] = "tfc:standard";
    EditionOption["tfcPlus"] = "tfc:plus";
    EditionOption[/**
	 * Deprecated pricing tiers as of March '23
	 * To be removed after all content is updated
	 */ "tfcFree"] = "tfc:free";
    EditionOption["tfcTeam"] = "tfc:team";
    EditionOption["tfcGov"] = "tfc:team_governance";
    EditionOption["tfcBiz"] = "tfc:business";
})(EditionOption || (EditionOption = {}));
var types_ThemeOption;
(function(ThemeOption) {
    ThemeOption["cloud"] = "cloud";
    ThemeOption["hashicorp"] = "hashicorp";
})(types_ThemeOption || (types_ThemeOption = {}));
var types_CollectionCategoryOption;
(function(CollectionCategoryOption) {
    CollectionCategoryOption["get_started"] = "Get Started";
    CollectionCategoryOption["fundamentals"] = "Fundamentals";
    CollectionCategoryOption["use_cases"] = "Use Cases";
    CollectionCategoryOption["certification"] = "Certification Prep";
    CollectionCategoryOption["production"] = "Production";
    CollectionCategoryOption["integrations"] = "Integrations";
    CollectionCategoryOption["kubernetes"] = "Kubernetes";
    CollectionCategoryOption["operations"] = "Operations";
})(types_CollectionCategoryOption || (types_CollectionCategoryOption = {}));
var VideoHostOption;
(function(VideoHostOption) {
    VideoHostOption["youtube"] = "youtube";
    VideoHostOption["wistia"] = "wistia";
})(VideoHostOption || (VideoHostOption = {}));
var HandsOnLabProviderOption;
(function(HandsOnLabProviderOption) {
    HandsOnLabProviderOption["katacoda"] = "katacoda";
    HandsOnLabProviderOption["instruqt"] = "instruqt";
})(HandsOnLabProviderOption || (HandsOnLabProviderOption = {}));
var CompanyLogoOption;
(function(CompanyLogoOption) {
    CompanyLogoOption["docker"] = "docker";
    CompanyLogoOption["github"] = "github";
    CompanyLogoOption["microsoft-azure"] = "microsoft-azure";
    CompanyLogoOption["oci"] = "oci";
    CompanyLogoOption["google-cloud"] = "google-cloud";
    CompanyLogoOption["terraform-cloud"] = "terraform-cloud";
    CompanyLogoOption["aws"] = "aws";
})(CompanyLogoOption || (CompanyLogoOption = {}));
var types_TutorialProgressStatus;
(function(TutorialProgressStatus) {
    TutorialProgressStatus["visited"] = "visited";
    TutorialProgressStatus["in_progress"] = "in_progress";
    TutorialProgressStatus["complete"] = "complete";
})(types_TutorialProgressStatus || (types_TutorialProgressStatus = {}));
var types_TutorialProgressPercent;
(function(TutorialProgressPercent) {
    TutorialProgressPercent["Zero"] = "0";
    TutorialProgressPercent["TwentyFive"] = "25";
    TutorialProgressPercent["Fifty"] = "50";
    TutorialProgressPercent["SeventyFive"] = "75";
    TutorialProgressPercent["Ninety"] = "90";
    TutorialProgressPercent["OneHundred"] = "100";
})(types_TutorialProgressPercent || (types_TutorialProgressPercent = {}));
/**
 * TYPE GUARDS ---------------------------------
 */ //  type guard to distinguish products from themes
function themeIsProduct(theme) {
    return types_isProductOption(theme);
}
/**
 * Type guard to determine if a string is a ThemeOption or ProductOption
 */ function isThemeOrProduct(string) {
    return isThemeOption(string) || types_isProductOption(string);
}
/**
 * Type guard to determine if a string is a ThemeOption
 */ function isThemeOption(string) {
    return Object.values(types_ThemeOption).includes(string);
}
/**
 * Type guard to determine if a string is a SectionOption
 */ function types_isSectionOption(string) {
    return Object.values(SectionOption).includes(string);
}
/**
 * Type guard to determine if a string is a ProductOption
 */ function types_isProductOption(string) {
    return Object.values(ProductOption).includes(string);
}

;// CONCATENATED MODULE: ./src/views/tutorial-view/utils/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
function splitProductFromFilename(slug) {
    return slug.split("/")[1];
}
// Handles variant routes that in the url show as query params,
// but are rewritten to static paths in middleware. We want to check
// against the default tutorial path for 'current', not with the variant
function cleanVariantFromPath(tutorialPath) {
    const currentPathParts = tutorialPath.split("/");
    // Expected variant tutorial path structure
    // /:product/tutorials/:collection/:tutorial/:variant
    const isVariantPath = currentPathParts.length === 6 && currentPathParts[5].includes(":");
    if (isVariantPath) {
        currentPathParts.pop();
    }
    return currentPathParts.join("/");
}
function formatTutorialToMenuItem(tutorial, collection, currentPath) {
    const path = getTutorialSlug(tutorial.slug, collection.slug);
    const currentPathWithoutVariant = cleanVariantFromPath(currentPath);
    return {
        tutorialId: tutorial.id,
        collectionId: collection.id,
        text: tutorial.name,
        href: path,
        isActive: path === currentPathWithoutVariant
    };
}
function generateCanonicalUrl(defaultCollectionSlug, tutorialSlug) {
    const path = getTutorialSlug(tutorialSlug, defaultCollectionSlug);
    return new URL(path, "https://developer.hashicorp.com");
}

;// CONCATENATED MODULE: ./src/lib/products.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ /**
 * A map of product slugs to their proper noun names.
 *
 * 🚨 NOTE: the order of this object matters for the Home page.
 */ const products_productSlugsToNames = {
    sentinel: "Sentinel",
    hcp: "HashiCorp Cloud Platform",
    terraform: "Terraform",
    packer: "Packer",
    consul: "Consul",
    vault: "Vault",
    boundary: "Boundary",
    nomad: "Nomad",
    waypoint: "Waypoint",
    vagrant: "Vagrant"
};
/**
 * A map of product slugs to their "dot io" site hostname.
 */ const productSlugsToHostNames = {
    boundary: "boundaryproject.io",
    consul: "consul.io",
    hcp: "cloud.hashicorp.com",
    nomad: "nomadproject.io",
    packer: "packer.io",
    sentinel: "docs.hashicorp.com",
    terraform: "terraform.io",
    vagrant: "vagrantup.com",
    vault: "vaultproject.io",
    waypoint: "waypointproject.io"
};
/**
 * Type guard to determine if a string is a ProductSlug
 *
 * TODO: should we define ProductSlug as an enum,
 * so that we can use its values directly here?
 */ function products_isProductSlug(string) {
    return Object.keys(products_productSlugsToNames).includes(string);
}
/**
 * An array of all Product slugs, generated from `productSlugsToNames`.
 */ const productSlugs = Object.keys(products_productSlugsToNames);
/**
 * An array of product slugs which are "active" on the site. Currently all but sentinel.
 */ const activeProductSlugs = productSlugs.filter((slug)=>slug !== "sentinel");
/**
 * Generates an array of Product objects from `productSlugs`.
 */ const products = productSlugs.map((slug)=>{
    const name = products_productSlugsToNames[slug];
    return {
        name,
        slug
    };
});


;// CONCATENATED MODULE: ./src/lib/tutorials/normalize-product-like-slug.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Given a "product" slug from a Tutorials context,
 * such as in part of a collection or tutorial slug,
 * Return a "product" slug compatible with Dev Dot's ProductSlug type.
 *
 * This is very specifically targeted at normalizing "cloud" to "hcp".
 * In Tutorials contexts, we use "cloud"; in Dev Dot we use "hcp".
 */ function normalize_product_like_slug_normalizeSlugForDevDot(productSlug) {
    if (productSlug == "cloud") {
        return "hcp";
    } else if (products_isProductSlug(productSlug)) {
        return productSlug;
    } else if (types_isSectionOption(productSlug)) {
        return productSlug;
    } else {
        console.warn(`Error: unrecognized incoming Tutorials slug "${productSlug}" in normalizeSlugForDevDot.`);
    }
}
/**
 * Given a "product" slug from a Dev Dot context,
 * such as in part of a URL,
 * Return a "product" slug compatible with the Learn API.
 *
 * This is very specifically targeted at normalizing "hcp" to "cloud".
 * In Tutorials contexts, we use "cloud"; in Dev Dot we use "hcp".
 */ function normalizeSlugForTutorials(slug) {
    if (slug == "hcp" || slug == "cloud") {
        return ThemeOption.cloud;
    } else if (isProductOption(slug)) {
        return slug;
    } else if (isSectionOption(slug)) {
        return slug;
    } else {
        console.warn(`Error: unrecognized incoming productSlug "${slug}" in normalizeSlugForTutorials.`);
    }
}

;// CONCATENATED MODULE: ./src/views/collection-view/helpers/get-slug.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * takes db slug format --> waypoint/intro
 * and turns it to --> waypoint/tutorials/get-started-docker/intro
 *
 * We want to make sure to use the collection product in the path as
 * that sets the proper product context. The tutorial db slug may
 * reference a different product context
 */ function get_slug_getTutorialSlug(tutorialDbSlug, collectionDbSlug) {
    const [rawProductSlug, collectionFilename] = collectionDbSlug.split("/");
    const tutorialFilename = splitProductFromFilename(tutorialDbSlug);
    // @TODO genericize this to use 'topic' or 'section' instead of 'product'
    if (rawProductSlug === "well-architected-framework" || rawProductSlug === "onboarding") {
        return `/${collectionDbSlug}/${tutorialFilename}`;
    }
    // rawProductSlug may be "cloud", needs to be "hcp" for Dev Dot purposes
    const productSlug = normalize_product_like_slug_normalizeSlugForDevDot(rawProductSlug);
    return `/${productSlug}/tutorials/${collectionFilename}/${tutorialFilename}`;
}
function get_slug_getCollectionSlug(collectionDbSlug) {
    const [rawProductSlug, collectionFilename] = collectionDbSlug.split("/");
    // @TODO genericize this to use 'topic' or 'section' instead of 'product'
    if (rawProductSlug === "well-architected-framework" || rawProductSlug === "onboarding") {
        return `/${collectionDbSlug}`;
    }
    // rawProductSlug may be "cloud", needs to be "hcp" for Dev Dot purposes
    const productSlug = normalizeSlugForDevDot(rawProductSlug);
    return `/${productSlug}/tutorials/${collectionFilename}`;
}

;// CONCATENATED MODULE: ./src/views/collection-view/helpers/format-sidebar-sections.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * This function creates an array of collection category
 * sections for the sidebar. The sections include the associated
 * collections with that category. The collection category order
 * and options are linked to the `CollectionCategoryOption` enum
 */ function formatSidebarCategorySections(collections, currentSlug) {
    const categorySlugs = Object.keys(CollectionCategoryOption);
    /**
	 * Track which collections have been used in sidebar categories,
	 * so that we can ensure any non-categorized collections are still displayed.
	 */ const usedCollections = [];
    const sidebarSectionsByCategory = categorySlugs.map((category)=>{
        // get collections associated with that category
        const items = collections.filter((c)=>{
            const isInCategory = c.category === category;
            if (isInCategory) {
                usedCollections.push(c.slug);
            }
            return isInCategory;
        });
        return {
            title: CollectionCategoryOption[category],
            items: items.map((collection)=>formatCollectionToListItem(collection, currentSlug))
        };
    });
    /**
	 * If we have category sections with content, use those.
	 */ const nonEmptySections = filterEmptySections(sidebarSectionsByCategory);
    if (nonEmptySections.length > 0) {
        return nonEmptySections;
    }
    /**
	 * Otherwise, since there are no other sidebar sections, then
	 * add an "unused" section, to capture any missing collections
	 * Note: this will be filtered out if it's empty.
	 *
	 * TODO: this is to get /hcp content stubbed, may not be correct,
	 * and may need adjustment once we have finalized designs.
	 */ const remainderCollections = collections.filter((c)=>{
        return usedCollections.indexOf(c.slug) == -1;
    });
    const remainderSection = {
        /**
		 * Note: section title is not included, only option I can think of
		 * is "Collections", which I think we want to avoid naming explicitly?
		 * And would look weird next to other more specifically named sections.
		 */ items: remainderCollections.map((collection)=>formatCollectionToListItem(collection, currentSlug))
    };
    return filterEmptySections([
        remainderSection
    ]);
}
function filterEmptySections(sections) {
    return sections.filter((c)=>c.items.length > 0);
}
function formatCollectionToListItem(collection, currentSlug) {
    const path = getCollectionSlug(collection.slug);
    return {
        text: collection.shortName,
        href: path,
        isActive: collection.slug === currentSlug
    };
}

;// CONCATENATED MODULE: ./src/content/hcp/tutorials-sidebar.json
const tutorials_sidebar_namespaceObject = {};
;// CONCATENATED MODULE: ./src/views/collection-view/helpers/generate-hcp-sidebar.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


/**
 * The HCP tutorials landing and collection
 * sidebar is unique from other product sidebars.
 * The `genericHcpCollections` represent the actual
 * collections under 'cloud' in the filesystem. However,
 * there are additional cloud related collections for each
 * HCP product that we link to, but these live under their
 * specific product directory (e.g. vault/get-started-hcp )
 *
 * The additional sidebar categories to link to these product
 * collections are managed in a static JSON file in the content dir.
 *
 * This is considered an interim implementation for the GA launch.
 * Ideally, we could adjust the content structure so this sidebar
 * is generated based on the filesystem, like the other products.
 */ function buildCategorizedHcpSidebar(allCollections, currentSlug) {
    const genericHcpCollections = [
        {
            title: "HashiCorp Cloud Platform",
            items: allCollections.sort(sortAlphabetically("name")).map((collection)=>{
                const href = getCollectionSlug(collection.slug);
                return {
                    text: collection.name,
                    href,
                    isActive: collection.slug === currentSlug
                };
            })
        }
    ];
    const categorizedNonHcpCollections = hcpContent.sidebarCategories.map((category)=>({
            title: category.name,
            items: category.items.map((item)=>{
                const href = getCollectionSlug(item.collectionSlug);
                const badge = item.isBeta ? {
                    text: "Beta",
                    type: "outlined",
                    color: "neutral"
                } : undefined;
                return {
                    text: item.name,
                    href,
                    badge,
                    isActive: false
                };
            })
        }));
    return [
        ...genericHcpCollections,
        ...categorizedNonHcpCollections
    ];
}

// EXTERNAL MODULE: external "react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(20997);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(16689);
// EXTERNAL MODULE: external "next/router"
var router_ = __webpack_require__(71853);
;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-horizontal-rule/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

const sidebar_horizontal_rule_SidebarHorizontalRule = ()=>{
    return /*#__PURE__*/ _jsx("hr", {
        className: s.root
    });
};
/* harmony default export */ const sidebar_horizontal_rule = ((/* unused pure expression or super */ null && (sidebar_horizontal_rule_SidebarHorizontalRule)));

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/home-16.tsx
var home_16 = __webpack_require__(19663);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/chevron-right-16.tsx
var chevron_right_16 = __webpack_require__(81956);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/external-link-16.tsx
var external_link_16 = __webpack_require__(85309);
// EXTERNAL MODULE: external "classnames"
var external_classnames_ = __webpack_require__(59003);
;// CONCATENATED MODULE: ./src/components/badge/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const badge_Badge = ({ ariaLabel , className , color ="neutral" , icon , size ="medium" , text , type ="filled"  })=>{
    const classes = classNames(s.root, s[size], s[`${type}-${color}`], type === "base" && s.base, className);
    const hasIcon = !!icon;
    const hasText = !!text;
    const hasLabel = !!ariaLabel;
    const isIconOnly = hasIcon && !hasText;
    const isStatusBadge = color == "success" || color == "warning" || color == "error";
    if (isStatusBadge && !hasIcon) {
        throw new Error("`Badge`s used for communicating status must have an icon to avoid relying on color alone.");
    }
    if (!hasIcon && !hasText) {
        throw new Error("`Badge` must have either `text` or an `icon` with accessible labels.");
    }
    if (isIconOnly && !hasLabel) {
        throw new Error("Icon-only `Badge`s require an accessible label. Either provide the `text` or `ariaLabel` prop.");
    }
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx("span", {
                className: "g-screen-reader-only",
                children: ariaLabel ?? text
            }),
            /*#__PURE__*/ _jsxs("span", {
                "aria-hidden": true,
                className: classes,
                children: [
                    icon,
                    text && /*#__PURE__*/ _jsx("span", {
                        children: text
                    })
                ]
            })
        ]
    });
};
/* harmony default export */ const badge = ((/* unused pure expression or super */ null && (badge_Badge)));

// EXTERNAL MODULE: ./node_modules/next/link.js
var next_link = __webpack_require__(77262);
;// CONCATENATED MODULE: external "@react-aria/utils"
const external_react_aria_utils_namespaceObject = require("@react-aria/utils");
;// CONCATENATED MODULE: external "react-hot-toast"
const external_react_hot_toast_namespaceObject = require("react-hot-toast");
;// CONCATENATED MODULE: ./src/components/toast/components/toaster/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * react-hot-toast's Toaster component, with predefined settings.
 * Removes default toast styling from react-hot-toast,
 * and manages styling within the Notification components.
 *
 * Note: largely duplicative of a similar component in @hashicorp/react-toast:
 * https://github.com/hashicorp/react-components/blob/main/packages/toast/toaster/index.tsx
 */ function Toaster() {
    return /*#__PURE__*/ _jsx(ReactHotToaster, {
        position: "bottom-right",
        gutter: 16,
        containerStyle: {
            inset: 24,
            // z-index is one less than the reach dialog overlay's
            zIndex: 99
        },
        toastOptions: {
            style: {
                margin: 0,
                padding: 0,
                maxWidth: 404,
                width: "100%",
                backgroundColor: "transparent",
                boxShadow: "none",
                borderRadius: 0
            }
        }
    });
}

;// CONCATENATED MODULE: ./src/components/toast/components/toast-display/types.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ var types_ToastColor;
(function(ToastColor) {
    ToastColor["neutral"] = "neutral";
    ToastColor["highlight"] = "highlight";
    ToastColor["success"] = "success";
    ToastColor["warning"] = "warning";
    ToastColor["critical"] = "critical";
})(types_ToastColor || (types_ToastColor = {}));

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/x-16.tsx
var x_16 = __webpack_require__(89428);
;// CONCATENATED MODULE: ./src/components/toast/components/close-button/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



/**
 * "X" button, for closing modals and toasts, for example.
 * Mostly duplicative of @hashicorp/react-close-button.
 */ function close_button_CloseButton({ ariaLabel , className , onClick  }) {
    return /*#__PURE__*/ _jsx("button", {
        "aria-label": ariaLabel,
        className: classNames(s.closeButton, className),
        onClick: onClick,
        children: /*#__PURE__*/ _jsx(IconX16, {})
    });
}

;// CONCATENATED MODULE: ./src/components/toast/components/toast-display/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




const IS_DEV = (/* unused pure expression or super */ null && ("production" !== "production"));
/**
 * Display component for use with a toast library,
 * such as react-hot-toast.
 */ function toast_display_ToastDisplay({ title , description , color =ToastColor.neutral , icon , renderActions , dismissSelf  }) {
    /**
	 * In development, throw an error if a toast has
	 * no title and no description (except when using custom content).
	 */ if (IS_DEV && !title && !description) {
        throw new Error(`Toast must be provided either a "title" or a "description", or you must use "children" to render custom content in the Toast. Please ensure toast has a non-empty string for its "title" or "description", or provide custom "children" content to render.`);
    }
    return /*#__PURE__*/ _jsxs("div", {
        className: classNames(s.root, s[`color-${color}`]),
        children: [
            icon ? /*#__PURE__*/ _jsx("div", {
                className: s.iconArea,
                children: icon
            }) : null,
            /*#__PURE__*/ _jsxs("div", {
                className: s.contentArea,
                children: [
                    title ? /*#__PURE__*/ _jsx("p", {
                        className: s.title,
                        children: title
                    }) : null,
                    description ? /*#__PURE__*/ _jsx("p", {
                        className: s.description,
                        children: description
                    }) : null,
                    typeof renderActions == "function" ? /*#__PURE__*/ _jsx("div", {
                        className: s.actions,
                        children: renderActions({
                            dismissSelf
                        })
                    }) : null
                ]
            }),
            /*#__PURE__*/ _jsx("div", {
                className: s.closeArea,
                children: /*#__PURE__*/ _jsx(CloseButton, {
                    onClick: dismissSelf,
                    ariaLabel: "Dismiss notification"
                })
            })
        ]
    });
}
/* harmony default export */ const toast_display = ((/* unused pure expression or super */ null && (toast_display_ToastDisplay)));

;// CONCATENATED MODULE: ./src/components/toast/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 







const AUTO_DISMISS_DEFAULT_MS = 4000;
/**
 * Wraps our ToastDisplay component in react-hot-toast.
 */ function toast({ renderActions , color , description , icon , title , onDismissCallback =()=>null , autoDismiss =AUTO_DISMISS_DEFAULT_MS , dismissOnRouteChange =true  }) {
    // Determine the auto-dismiss duration
    let duration;
    if (autoDismiss == false) {
        duration = Infinity;
    } else if (typeof autoDismiss == "number" && autoDismiss > 0) {
        duration = autoDismiss;
    } else {
        duration = AUTO_DISMISS_DEFAULT_MS;
    }
    // Return a react-hot-toast
    return reactHotToast((t)=>{
        const [initialRoute, setInitialRoute] = useState(null);
        const router = useRouter();
        // Allows the toast to dismiss itself
        const dismissSelf = useCallback(()=>{
            onDismissCallback();
            reactHotToast.remove(t.id);
        }, [
            t.id
        ]);
        /**
			 * If specified, when the route changes, we should dismiss the toast.
			 * Note: there is a long-standing bug that prevents us from using
			 * the more expected routeChangComplete event from NextJS:
			 * https://github.com/vercel/next.js/issues/11639
			 */ useEffect(()=>{
            if (initialRoute == null) {
                setInitialRoute(router.pathname);
            } else {
                const isRouteChanged = router.pathname !== initialRoute;
                if (isRouteChanged && dismissOnRouteChange) {
                    dismissSelf();
                }
            }
        }, [
            router.pathname,
            initialRoute,
            setInitialRoute,
            dismissSelf
        ]);
        return /*#__PURE__*/ _jsx(ToastDisplay, {
            renderActions: renderActions,
            color: color,
            description: description,
            icon: icon,
            dismissSelf: dismissSelf,
            title: title
        });
    }, {
        duration,
        /**
			 * Note: in theory, style: { margin: 0 } should work here,
			 * and in fact should already be applied from ./components/toaster
			 * style settings, but in practice it does not seem to.
			 * We add a className that ensures margin actually gets set to 0.
			 */ className: s.removeMarginFix
    });
}
/**
 * A toast that only renders in non 'production' environments.
 */ const toast_developmentToast = (...args)=>{
    if (false) {}
};

/**
 * Note: default export is used in Swingset.
 * ToastDisplay should generally NOT be used directly.
 */ /* harmony default export */ const components_toast = ((/* unused pure expression or super */ null && (ToastDisplay)));

;// CONCATENATED MODULE: ./src/components/link/helpers/validate-props.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Validates some of the props passed into the component.
 */ const validate_props_validateProps = ({ opensInNewTab , target  })=>{
    /**
	 * Generate the `target` prop.
	 *
	 * @NOTE The `opensInNewTab` prop takes precedence over the `target` prop.
	 * This is because the `opensInNewTab` prop renders a screen-reader-only label
	 * when `true`. If both `opensInNewTab` and `target` were passed, and `target`
	 * did not have the value of `"_blank"`, then the screen-reader-only label
	 * would not be accurate.
	 */ if (opensInNewTab && !!target) {
        developmentToast({
            color: ToastColor.critical,
            title: "Error in src/components/Link",
            description: "Both `opensInNewTab` and `target` were passed. Only pass one or the other."
        });
    }
};


;// CONCATENATED MODULE: ./src/components/link/helpers/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

;// CONCATENATED MODULE: ./src/components/link/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



const ARIA_DESCRIBED_BY_PREFIX = "opens-in-new-tab-label";
/**
 * A wrapper for the next/link component that also handles unique functionality
 * with the `opensInNewTab` prop.
 *
 * When `opensInNewTab` is passed, a `<span>` with the `g-screen-reader-only`
 * class is rendered with "(opens in new tab)" as its inner text. This approach
 * is inspired by WCAG 2.1 Technique G201: Giving users advanced warning when
 * opening a new window.
 *
 * https://www.w3.org/WAI/WCAG21/Techniques/general/G201
 */ const link_Link = ({ children , href , opensInNewTab , ...restProps })=>{
    validateProps({
        opensInNewTab,
        target: restProps.target
    });
    const uniqueId = useId();
    const opensInNewTabLabelId = `${ARIA_DESCRIBED_BY_PREFIX}-${uniqueId}`;
    const shouldRenderScreenReaderOnlyMessage = opensInNewTab === true || restProps.target === "_blank";
    /**
	 * Generate the final link's `target` prop.
	 */ const target = opensInNewTab ? "_blank" : restProps.target;
    /**
	 * Generate the final link's `aria-describedby` prop.
	 */ let ariaDescribedBy;
    if (shouldRenderScreenReaderOnlyMessage) {
        ariaDescribedBy += opensInNewTabLabelId;
    }
    if (restProps["aria-describedby"]?.length > 0) {
        ariaDescribedBy += ` ${restProps["aria-describedby"]}`;
    }
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(NextLink, {
                href: href,
                ...restProps,
                "aria-describedby": ariaDescribedBy,
                target: target,
                children: children
            }),
            shouldRenderScreenReaderOnlyMessage ? /*#__PURE__*/ _jsx("span", {
                className: "g-screen-reader-only",
                id: opensInNewTabLabelId,
                children: "(opens in new tab)"
            }) : null
        ]
    });
};
/* harmony default export */ const components_link = ((/* unused pure expression or super */ null && (link_Link)));

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/boundary-16.tsx
var boundary_16 = __webpack_require__(63438);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/boundary-24.tsx
var boundary_24 = __webpack_require__(14505);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/consul-16.tsx
var consul_16 = __webpack_require__(93654);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/consul-24.tsx
var consul_24 = __webpack_require__(71972);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/hcp-16.tsx
var hcp_16 = __webpack_require__(46495);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/hcp-24.tsx
var hcp_24 = __webpack_require__(37886);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/nomad-16.tsx
var nomad_16 = __webpack_require__(12394);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/nomad-24.tsx
var nomad_24 = __webpack_require__(81378);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/packer-16.tsx
var packer_16 = __webpack_require__(92070);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/packer-24.tsx
var packer_24 = __webpack_require__(11332);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/terraform-16.tsx
var terraform_16 = __webpack_require__(73799);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/terraform-24.tsx
var terraform_24 = __webpack_require__(17628);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/vagrant-color-16.tsx
var vagrant_color_16 = __webpack_require__(79136);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/vagrant-color-24.tsx
var vagrant_color_24 = __webpack_require__(68309);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/vault-16.tsx
var vault_16 = __webpack_require__(37477);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/vault-24.tsx
var vault_24 = __webpack_require__(75712);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/waypoint-16.tsx
var waypoint_16 = __webpack_require__(78644);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/waypoint-24.tsx
var waypoint_24 = __webpack_require__(9419);
;// CONCATENATED MODULE: ./src/components/product-icon/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


















const productSlugsToIcons = {
    boundary: {
        16: boundary_16/* IconBoundary16 */.O,
        24: boundary_24/* IconBoundary24 */.J
    },
    consul: {
        16: consul_16/* IconConsul16 */.L,
        24: consul_24/* IconConsul24 */.v
    },
    hcp: {
        16: hcp_16/* IconHcp16 */.u,
        24: hcp_24/* IconHcp24 */.B
    },
    nomad: {
        16: nomad_16/* IconNomad16 */.E,
        24: nomad_24/* IconNomad24 */.N
    },
    packer: {
        16: packer_16/* IconPacker16 */.o,
        24: packer_24/* IconPacker24 */._
    },
    terraform: {
        16: terraform_16/* IconTerraform16 */.V,
        24: terraform_24/* IconTerraform24 */.$
    },
    vagrant: {
        16: vagrant_color_16/* IconVagrantColor16 */.G,
        24: vagrant_color_24/* IconVagrantColor24 */.k
    },
    vault: {
        16: vault_16/* IconVault16 */.O,
        24: vault_24/* IconVault24 */.D
    },
    waypoint: {
        16: waypoint_16/* IconWaypoint16 */.o,
        24: waypoint_24/* IconWaypoint24 */.c
    }
};
const product_icon_ProductIcon = ({ productSlug , size =16 , ...rest })=>{
    const Icon = productSlugsToIcons[productSlug] ? productSlugsToIcons[productSlug][size] : null;
    if (!Icon) {
        return null;
    }
    // Color should inherit from parent for hcp
    const color = productSlug === "hcp" ? undefined : `var(--token-color-${productSlug}-brand)`;
    /**
	 * The color is set here for theming purposes. We import the logo without
	 * color and then set the product brand color since all the product icons
	 * have a single fill color.
	 */ return /*#__PURE__*/ _jsx(Icon, {
        ...rest,
        color: color
    });
};
/* harmony default export */ const product_icon = ((/* unused pure expression or super */ null && (product_icon_ProductIcon)));

;// CONCATENATED MODULE: ./src/components/text/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const text_Text = ({ asElement ="p" , size =300 , weight ="regular" , ...rest })=>{
    const className = classNames(s.root, `hds-typography-body-${size}`, `hds-font-weight-${weight}`, rest.className);
    const passableProps = {
        ...rest,
        className
    };
    const TextElement = asElement;
    return /*#__PURE__*/ _jsx(TextElement, {
        ...passableProps
    });
};
/* harmony default export */ const components_text = ((/* unused pure expression or super */ null && (text_Text)));

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-nav-menu-item/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 











/**
 * Used for leading icon in `SidebarNavLinkItem`.
 */ const SUPPORTED_LEADING_ICONS = {
    home: /*#__PURE__*/ jsx_runtime_.jsx(home_16/* IconHome16 */._, {
        name: "home"
    })
};
/**
 * Handles rendering the content of the right-side of a `SidebarNavMenuItem`.
 * This content may include one `Badge`, one `Icon`, one of each, or neither.
 * Returns `null` if neither are provided.
 */ const RightIconsContainer = ({ badge , icon  })=>{
    if (!badge && !icon) {
        return null;
    }
    return /*#__PURE__*/ _jsxs("div", {
        className: s.rightIconsContainer,
        children: [
            badge,
            icon
        ]
    });
};
/**
 * A wrapper around Badge for rendering consistent Badges in SidebarNavMenuItem.
 */ const SidebarNavMenuItemBadge = ({ color , text , type  })=>{
    if (color !== "highlight" && color !== "neutral") {
        throw new Error(`[SidebarNavMenuItemBadge] Only the "highlight" and "neutral" colors are supported for Badges, but was given ${color}.`);
    }
    return /*#__PURE__*/ _jsx(Badge, {
        color: color,
        size: "small",
        text: text,
        type: type
    });
};
/**
 * Handles rendering a link menu item in the Sidebar. Will automatically
 * determine whether or not the link is external to DevDot, and will render an
 * external link icon if the link is external.
 */ const sidebar_nav_menu_item_SidebarNavLinkItem = ({ item  })=>{
    const href = item.fullPath || item.href;
    const isExternal = isAbsoluteUrl(href);
    const hasBadge = !!item.badge;
    // Determine the leading icon to use, if any
    let leadingIcon;
    if (item.leadingIconName) {
        const icon = SUPPORTED_LEADING_ICONS[item.leadingIconName] || /*#__PURE__*/ _jsx(ProductIcon, {
            productSlug: item.leadingIconName
        });
        leadingIcon = /*#__PURE__*/ _jsx("div", {
            className: s.leadingIcon,
            children: icon
        });
    }
    // Determine the trailing icon to use, if any
    const trailingIcon = isExternal ? /*#__PURE__*/ _jsx(IconExternalLink16, {}) : item.trailingIcon;
    const ariaCurrent = !isExternal && item.isActive ? "page" : undefined;
    const [isMounted, setIsMounted] = useState(false);
    /**
	 * Note on this useEffect:
	 *
	 * Due to how we are rewriting routes for tutorial variants, the URLs rendered in
	 * this component are incorrect during SSR, and for some reason are NOT
	 * getting reconciled on the client even though all of the props and state
	 * values internal to Link are correct. So the ariaCurrent value wasn't being
	 * set properly and the active item wouldn't render. We think its due to a hydration
	 * mismatch error. This set state ensures that after the component mounts, it gets resolved
	 * by forcing a rerender.
	 */ useEffect(()=>{
        setIsMounted(true);
    }, []);
    const ariaLabel = isExternal ? `${item.title}. Opens in a new tab.` : undefined;
    const className = s.sidebarNavMenuItem;
    const rel = isExternal ? "noreferrer noopener" : undefined;
    const anchorContent = /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            leadingIcon,
            /*#__PURE__*/ _jsx(Text, {
                asElement: "span",
                className: s.navMenuItemLabel,
                dangerouslySetInnerHTML: {
                    __html: item.title
                },
                size: 200,
                weight: "regular"
            }),
            /*#__PURE__*/ _jsx(RightIconsContainer, {
                badge: hasBadge ? /*#__PURE__*/ _jsx(SidebarNavMenuItemBadge, {
                    ...item.badge
                }) : undefined,
                icon: trailingIcon
            })
        ]
    });
    if (href) {
        // link is not "disabled"
        return /*#__PURE__*/ _jsx(Link, {
            "aria-current": ariaCurrent,
            "aria-label": ariaLabel,
            className: className,
            "data-heap-track": "sidebar-nav-link-item",
            href: href,
            opensInNewTab: isExternal,
            rel: rel,
            children: anchorContent
        }, String(isMounted));
    } else {
        // link is "disabled"
        return /*#__PURE__*/ _jsx("a", {
            "aria-disabled": true,
            "aria-label": item.ariaLabel,
            className: className,
            tabIndex: 0,
            children: anchorContent
        });
    }
};
/**
 * Handles rendering a button and icon for the sidebar.
 * Currently used for a 'sign out' action on the profile page
 */ function SidebarNavMenuButton({ item  }) {
    return /*#__PURE__*/ _jsxs("button", {
        className: s.sidebarNavMenuItem,
        onClick: item.onClick,
        children: [
            /*#__PURE__*/ _jsx(Text, {
                size: 200,
                weight: "regular",
                asElement: "span",
                className: s.navMenuItemLabel,
                children: item.title
            }),
            /*#__PURE__*/ _jsx(RightIconsContainer, {
                icon: item.icon
            })
        ]
    });
}
/**
 * Handles rendering a collapsible/expandable submenu item and its child menu
 * items in the Sidebar.
 */ const SidebarNavSubmenuItem = ({ item  })=>{
    const buttonRef = useRef();
    const [isOpen, setIsOpen] = useState(item.isOpen || item.hasActiveChild || item.hasChildrenMatchingFilter || item.matchesFilter);
    const hasBadge = !!item.badge;
    /**
	 * Without this effect, the menu items aren't re-rerendered to be open. Seems
	 * to be because the item prop sent to the component don't change. Might work
	 * if we pass the props needed instead of just the item object?
	 */ useEffect(()=>{
        setIsOpen(item.isOpen || item.hasActiveChild || item.hasChildrenMatchingFilter || item.matchesFilter);
    }, [
        item.isOpen,
        item.hasActiveChild,
        item.hasChildrenMatchingFilter,
        item.matchesFilter
    ]);
    const handleKeyDown = (e)=>{
        if (e.key === "Escape") {
            e.preventDefault();
            e.stopPropagation();
            setIsOpen(false);
            buttonRef.current.focus();
        }
    };
    const buttonId = `${item.id}-button`;
    const listId = `${item.id}-list`;
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsxs("button", {
                "aria-controls": listId,
                "aria-expanded": isOpen,
                className: s.sidebarNavMenuItem,
                id: buttonId,
                onClick: ()=>setIsOpen((prevState)=>!prevState),
                ref: buttonRef,
                "data-heap-track": "sidebar-nav-submenu-button",
                children: [
                    /*#__PURE__*/ _jsx(Text, {
                        asElement: "span",
                        className: s.navMenuItemLabel,
                        dangerouslySetInnerHTML: {
                            __html: item.title
                        },
                        size: 200,
                        weight: "regular"
                    }),
                    /*#__PURE__*/ _jsx(RightIconsContainer, {
                        badge: hasBadge ? /*#__PURE__*/ _jsx(SidebarNavMenuItemBadge, {
                            ...item.badge
                        }) : undefined,
                        icon: /*#__PURE__*/ _jsx(IconChevronRight16, {})
                    })
                ]
            }),
            isOpen && /*#__PURE__*/ _jsx("ul", {
                id: listId,
                onKeyDown: handleKeyDown,
                children: item.routes.map((route, i)=>{
                    const key = `${route.id || route.fullPath || route.title}-${i}`;
                    return /*#__PURE__*/ _jsx(sidebar_nav_menu_item_SidebarNavMenuItem, {
                        item: route
                    }, key);
                })
            })
        ]
    });
};
/**
 * Handles conditionally rendering one of the following based on the properties
 * of the `item` passed in:
 *  - SidebarHorizontalRule
 *  - SidebarSectionHeading
 *  - SidebarNavSubmenu
 *  - SidebarNavLink
 */ const sidebar_nav_menu_item_SidebarNavMenuItem = ({ item  })=>{
    let itemContent;
    if (item.divider) {
        itemContent = /*#__PURE__*/ _jsx(SidebarHorizontalRule, {});
    } else if (item.heading) {
        itemContent = /*#__PURE__*/ _jsx(SidebarSectionHeading, {
            text: item.heading
        });
    } else if (item.routes) {
        itemContent = /*#__PURE__*/ _jsx(SidebarNavSubmenuItem, {
            item: item
        });
    } else if (item.theme) {
        itemContent = /*#__PURE__*/ _jsx(SidebarNavHighlightItem, {
            theme: item.theme,
            text: item.title,
            href: item.fullPath,
            isActive: item.isActive
        });
    } else {
        itemContent = /*#__PURE__*/ _jsx(sidebar_nav_menu_item_SidebarNavLinkItem, {
            item: item
        });
    }
    return /*#__PURE__*/ _jsx("li", {
        id: item.id,
        children: itemContent
    });
};

/* harmony default export */ const sidebar_nav_menu_item = ((/* unused pure expression or super */ null && (sidebar_nav_menu_item_SidebarNavMenuItem)));

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-nav-highlight-item/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 





/**
 * Render a fancy-looking, product themed linked sidebar item.
 *
 * Intended to be used as a kind of title-ish element, to establish hierarchy
 * within sidebar contents.
 */ function sidebar_nav_highlight_item_SidebarNavHighlightItem({ theme , text , href , isActive  }) {
    return /*#__PURE__*/ _jsxs(Link, {
        "aria-current": isActive ? "page" : undefined,
        className: classNames(s.root, s[`theme-${theme}`]),
        href: href,
        children: [
            isProductSlug(theme) ? /*#__PURE__*/ _jsx(ProductIcon, {
                productSlug: theme
            }) : null,
            /*#__PURE__*/ _jsx("span", {
                className: s.text,
                children: text
            })
        ]
    });
}

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-skip-to-main-content/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

const sidebar_skip_to_main_content_SidebarSkipToMainContent = ()=>{
    return /*#__PURE__*/ _jsx("a", {
        className: s.root,
        href: "#main",
        children: "Skip to main content"
    });
};
/* harmony default export */ const sidebar_skip_to_main_content = ((/* unused pure expression or super */ null && (sidebar_skip_to_main_content_SidebarSkipToMainContent)));

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-headings/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Should be used for rendering the title of an entire Sidebar. There should
 * only be one rendered for a single Sidebar.
 *
 * An <h2> is rendered to set up the outline hierarchy of the Sidebar navigation
 * elements. If there are sections of elements, they should each be labelled
 * using a `SidebarSectionHeading`.
 *
 * It is OK that there is no <h1> in the Sidebar before this, and it is also OK
 * that the <h1> for a page appears after the Sidebar. What's important is that
 * we are not rendering more than one <h1> on a single page.
 *
 * See example 2 here: https://www.w3.org/WAI/tutorials/page-structure/headings/
 */ const sidebar_headings_SidebarTitleHeading = ({ id , text  })=>{
    return /*#__PURE__*/ _jsx("h2", {
        className: s.root,
        id: id,
        children: text
    });
};
/**
 * Used for labeling a section of Sidebar menu items. In the markup, this should
 * appear directly before the <ul> element that wraps the group of menu items.
 *
 * Use `SidebarTitleHeading` if you're looking to add a single title for an
 * entire Sidebar.
 */ const sidebar_headings_SidebarSectionHeading = ({ text  })=>{
    return /*#__PURE__*/ _jsx("h3", {
        className: s.root,
        children: text
    });
};


;// CONCATENATED MODULE: ./src/components/sidebar/components/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 






;// CONCATENATED MODULE: ./src/hooks/use-current-path.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Gets the current path similar to Next's router but optionally excludes the
 * hash and/or search portion of the path. Uses `window.location`.
 */ const use_current_path_useCurrentPath = (options = {})=>{
    const router = useRouter();
    const { excludeHash =false , excludeSearch =false  } = options;
    const { hash , pathname , search  } = new URL(router.asPath, // TODO: replace this with an environment variable soon
    "https://www.hashicorp.com");
    if (excludeHash && excludeSearch) {
        return pathname;
    }
    if (excludeHash) {
        return pathname + search;
    }
    if (excludeSearch) {
        return pathname + hash;
    }
    return pathname + search + hash;
};
/* harmony default export */ const use_current_path = ((/* unused pure expression or super */ null && (use_current_path_useCurrentPath)));

;// CONCATENATED MODULE: ./src/contexts/current-content-type.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

const CurrentContentTypeContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
CurrentContentTypeContext.displayName = "CurrentContentTypeContext";
/**
 * Stores the current content type being viewed in a page. This information is
 * useful when we want to show a different UI based on the type of content a
 * user is actively viewing.
 *
 * Example: Global Search will automatically show tutorial search results before
 * docs search when `currentContentType` is "tutorials".
 *
 * To change the value of `currentContentType`, the `contentType` property can
 * be added to a component that is rendered as a page. See `CustomPageComponent`
 * for reference.
 */ const CurrentContentTypeProvider = ({ children , currentContentType  })=>{
    return /*#__PURE__*/ _jsx(CurrentContentTypeContext.Provider, {
        value: currentContentType,
        children: children
    });
};
const useCurrentContentType = ()=>{
    const context = useContext(CurrentContentTypeContext);
    if (context === undefined) {
        throw new Error("useCurrentContentType must be used within a CurrentContentTypeProvider");
    }
    return context;
};


;// CONCATENATED MODULE: ./src/contexts/current-product.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const CurrentProductContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
CurrentProductContext.displayName = "CurrentProductContext";
const CurrentProductProvider = ({ children , currentProduct  })=>{
    const router = useRouter();
    const value = router.asPath === "/" ? null : currentProduct;
    return /*#__PURE__*/ _jsx(CurrentProductContext.Provider, {
        value: value,
        children: children
    });
};
const current_product_useCurrentProduct = ()=>{
    const context = useContext(CurrentProductContext);
    if (context === undefined) {
        throw new Error("useCurrentProduct must be used within a CurrentProductProvider");
    }
    return context;
};


;// CONCATENATED MODULE: ./src/contexts/device-size.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const DEFAULT_MOBILE_WIDTH = 728;
const DEFAULT_TABLET_WIDTH = 1000;
const DeviceSizeContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
DeviceSizeContext.displayName = "DeviceSizeContext";
const DeviceSizeProvider = ({ children  })=>{
    let mobileWidth;
    let tabletWidth;
    let mobileMediaQueryListObject;
    let tabletMediaQueryListObject;
    if (false) {}
    const getDerivedState = ()=>{
        const isMobile = mobileMediaQueryListObject?.matches;
        const isTablet = tabletMediaQueryListObject?.matches;
        const isDesktop = !(isMobile || isTablet);
        return {
            isDesktop,
            isMobile,
            isTablet
        };
    };
    const [value, setValue] = useState(()=>getDerivedState());
    useEffect(()=>{
        const handleChange = ()=>{
            setValue(getDerivedState());
        };
        mobileMediaQueryListObject.addEventListener("change", handleChange);
        tabletMediaQueryListObject.addEventListener("change", handleChange);
        return ()=>{
            mobileMediaQueryListObject.removeEventListener("change", handleChange);
            tabletMediaQueryListObject.removeEventListener("change", handleChange);
        };
    });
    return /*#__PURE__*/ _jsx(DeviceSizeContext.Provider, {
        value: value,
        children: children
    });
};
const useDeviceSize = ()=>{
    const context = useContext(DeviceSizeContext);
    if (context === undefined) {
        throw new Error("useDeviceSize must be used within a DeviceSizeProvider");
    }
    return context;
};


;// CONCATENATED MODULE: ./src/hooks/use-no-scroll-body.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Ensures the body can't be scrolled while the boolean
 * trigger passed is true
 */ function use_no_scroll_body_useNoScrollBody(trigger) {
    const [initialValue, setInitialValue] = useState(null);
    useEffect(()=>{
        if (initialValue === null) {
            setInitialValue(document.body.style.overflow);
        }
        if (trigger) {
            document.body.style.overflow = "hidden";
        } else if (!trigger && document.body.style.overflow === "hidden") {
            document.body.style.overflow = initialValue;
        }
        // reset on component unmount
        return ()=>{
            document.body.style.overflow = initialValue;
        };
    }, [
        trigger
    ]);
}

;// CONCATENATED MODULE: ./src/contexts/mobile-menu.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




/**
 * Should correspond to --dev-dot-hide-mobile-menu
 */ const DEFAULT_NAV_HEADER_DESKTOP_WIDTH = 924;
const MobileMenuContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
MobileMenuContext.displayName = "MobileMenuContext";
/**
 * Provider for managing open/closed state of the mobile menu.
 */ const MobileMenuProvider = ({ children  })=>{
    const router = useRouter();
    const [isMobileMenuRendered, setIsMobileMenuRendered] = useState(false);
    const [mobileMenuIsOpen, setMobileMenuIsOpen] = useState();
    /**
	 * NOTE: We cannot use `useDeviceSize` here because the nav header
	 * breakpoints are different than the breakpoints used elsewhere in the app.
	 */ useEffect(()=>{
        if (true) {
            return;
        }
        // Get the breakpoint value
        const desktopWidthBreakpoint = getCSSVariableFromDocument("--mobile-menu-breakpoint", {
            asNumber: true
        }) || DEFAULT_NAV_HEADER_DESKTOP_WIDTH;
        // Create a media query list object with the obtained breakpoint
        const mediaQueryListObject = window.matchMedia(`(min-width: ${desktopWidthBreakpoint}px)`);
        // Create a change listener for the media query list object
        // Called when the breakpoint is crossed over in either direction
        const handleChange = ()=>{
            const shouldRenderMobileMenu = !mediaQueryListObject.matches;
            setIsMobileMenuRendered(shouldRenderMobileMenu);
        };
        // Set the initial state based on the mediaQuery
        handleChange();
        // Add change listener
        mediaQueryListObject.addEventListener("change", handleChange);
        // Clean up; remove change listener
        return ()=>{
            mediaQueryListObject.removeEventListener("change", handleChange);
        };
    }, []);
    /**
	 * Prevents scrolling on the rest of the page body
	 */ useNoScrollBody(mobileMenuIsOpen);
    /**
	 * Handles closing the mobile menu in some cases.
	 */ useEffect(()=>{
        // Don't need to listen for router events on Desktop
        if (!isMobileMenuRendered) {
            // Close the mobile menu if the viewport size has crossed the breakpoint
            setMobileMenuIsOpen(false);
            return;
        }
        // Close the mobile menu if it's open on route change start
        const handleRouteChange = ()=>{
            if (mobileMenuIsOpen) {
                setMobileMenuIsOpen(false);
            }
        };
        router.events.on("routeChangeComplete", handleRouteChange);
        router.events.on("routeChangeError", handleRouteChange);
        return ()=>{
            router.events.off("routeChangeComplete", handleRouteChange);
            router.events.off("routeChangeError", handleRouteChange);
        };
    }, [
        isMobileMenuRendered,
        mobileMenuIsOpen,
        router.events
    ]);
    const state = {
        isMobileMenuRendered,
        mobileMenuIsOpen,
        setMobileMenuIsOpen
    };
    return /*#__PURE__*/ _jsx(MobileMenuContext.Provider, {
        value: state,
        children: children
    });
};
/**
 * Hook for exposing menu state and the setter for updating the state.
 */ const mobile_menu_useMobileMenu = ()=>{
    const context = useContext(MobileMenuContext);
    if (context === undefined) {
        throw new Error("useMobileMenu must be used within a MobileMenuProvider");
    }
    return context;
};


;// CONCATENATED MODULE: ./src/contexts/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/filter-16.tsx
var filter_16 = __webpack_require__(79379);
;// CONCATENATED MODULE: ./src/components/filter-input/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 





const filter_input_FilterInput = ({ placeholder ="Filter" , value , onChange , className , IconComponent =IconFilter16  })=>{
    const inputRef = useRef();
    const showClearButton = value;
    const handleChange = (e)=>{
        const newValue = e.target.value;
        onChange(newValue);
    };
    const handleClear = ()=>{
        onChange("");
        inputRef.current.focus();
    };
    return /*#__PURE__*/ _jsxs("div", {
        className: classNames(s.filterInputContainer, className),
        children: [
            /*#__PURE__*/ _jsx(IconComponent, {
                className: s.filterIcon
            }),
            /*#__PURE__*/ _jsx("input", {
                className: s.filterInput,
                onChange: handleChange,
                placeholder: placeholder,
                ref: inputRef,
                value: value,
                autoComplete: "off",
                autoCorrect: "off",
                autoCapitalize: "none",
                spellCheck: "false"
            }),
            showClearButton && /*#__PURE__*/ _jsx("button", {
                "aria-label": "Clear filter",
                className: s.clearButton,
                onClick: handleClear,
                children: /*#__PURE__*/ _jsx(IconX16, {})
            })
        ]
    });
};
/* harmony default export */ const filter_input = ((/* unused pure expression or super */ null && (filter_input_FilterInput)));

;// CONCATENATED MODULE: ./src/layouts/sidebar-sidecar/contexts/sidebar-nav-data.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const SidebarNavDataContext = /*#__PURE__*/ (0,external_react_.createContext)(undefined);
SidebarNavDataContext.displayName = "SidebarNavDataContext";
const SidebarNavDataProvider = ({ children , navDataLevels  })=>{
    const { mobileMenuIsOpen , setMobileMenuIsOpen , isMobileMenuRendered  } = useMobileMenu();
    const numberOfLevels = navDataLevels.length;
    const [currentLevel, setCurrentLevel] = useState(numberOfLevels - 1);
    /**
	 * Reset if the current level once the mobile menu is closed and also if the
	 * `navDataLevels` prop has changed.
	 */ useEffect(()=>{
        // Should not alter current level after opening the mobile menu
        if (mobileMenuIsOpen) {
            return;
        }
        // Rest to the last/lowest level
        setCurrentLevel(numberOfLevels - 1);
    }, [
        mobileMenuIsOpen,
        navDataLevels,
        numberOfLevels
    ]);
    // Derive booleans based on main state
    const hasManyLevels = numberOfLevels > 1;
    const isFirstLevel = currentLevel === 0;
    const isLastLevel = currentLevel === numberOfLevels - 1;
    const shouldRenderMobileControls = hasManyLevels && isMobileMenuRendered;
    // Create state object to pass to the Provider
    const state = {
        currentLevel,
        hasManyLevels,
        isFirstLevel,
        isLastLevel,
        mobileMenuIsOpen,
        setCurrentLevel,
        setMobileMenuIsOpen,
        shouldRenderMobileControls
    };
    return /*#__PURE__*/ _jsx(SidebarNavDataContext.Provider, {
        value: state,
        children: children
    });
};
const sidebar_nav_data_useSidebarNavData = ()=>{
    const context = useContext(SidebarNavDataContext);
    if (context === undefined) {
        throw new Error("useSidebarNavData must be used within a SidebarNavDataProvider");
    }
    return context;
};


;// CONCATENATED MODULE: ./src/views/certifications/content/utils/program-slug-map.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ /**
 * Map a product that has certifications
 * to its corresponding certification program name.
 */ const program_slug_map_certificationProgramSlugMap = {
    consul: "networking-automation",
    terraform: "infrastructure-automation",
    vault: "security-automation"
};

;// CONCATENATED MODULE: ./src/views/tutorial-library/constants.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * The Algolia index we are searching against for tutorials
 */ const INDEX_NAME = (/* unused pure expression or super */ null && ("prod_LEARN"));
/**
 * Duration used to throttle search requests to avoid excessive network calls
 */ const SEARCH_TIMEOUT_MS = 200;
/**
 * Controls the resources filters, attribute is the name on the indexed tutorial object in Algolia
 */ const RESOURCES = [
    {
        label: "Video",
        attribute: "hasVideo"
    },
    {
        label: "Interactive",
        attribute: "isInteractive"
    }
];
/**
 * Controls the editions filters, values map to those specified on the indexed tutorial object in Algolia
 */ const EDITIONS = [
    {
        value: "open_source",
        label: "Open Source"
    },
    {
        value: "enterprise",
        label: "Enterprise"
    },
    {
        value: "tfc",
        label: "Terraform Cloud"
    },
    {
        value: "hcp",
        label: "HashiCorp Cloud Platform (HCP)"
    }
];
/**
 * Valid edition slugs for filtering tutorials by.
 */ const constants_VALID_EDITION_SLUGS_FOR_FILTERING = EDITIONS.map((edition)=>edition.value);
/**
 * Valid product slugs for filtering tutorials by. Currently, excludes hcp and sentinel and
 * only has our core products.
 */ const constants_VALID_PRODUCT_SLUGS_FOR_FILTERING = Object.keys(products_productSlugsToNames).filter((slug)=>![
        "hcp",
        "sentinel"
    ].includes(slug));

;// CONCATENATED MODULE: ./src/components/sidebar/helpers/generate-resources-nav-items.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

const DEFAULT_COMMUNITY_FORUM_LINK = "https://discuss.hashicorp.com/";
const DEFAULT_GITHUB_LINK = "https://github.com/hashicorp";
const DEFAULT_SUPPORT_LINK = "https://www.hashicorp.com/customer-success";
const COMMUNITY_LINKS_BY_PRODUCT = {
    boundary: "https://discuss.hashicorp.com/c/boundary/50",
    consul: "https://discuss.hashicorp.com/c/consul/29",
    hcp: "https://discuss.hashicorp.com/c/hcp/54",
    nomad: "https://discuss.hashicorp.com/c/nomad/28",
    packer: "https://discuss.hashicorp.com/c/packer/23",
    sentinel: "https://discuss.hashicorp.com/c/sentinel/25",
    terraform: "https://discuss.hashicorp.com/c/terraform-core/27",
    vagrant: "https://discuss.hashicorp.com/c/vagrant/24",
    vault: "https://discuss.hashicorp.com/c/vault/30",
    waypoint: "https://discuss.hashicorp.com/c/waypoint/51"
};
const GITHUB_LINKS_BY_PRODUCT_SLUG = {
    boundary: "https://github.com/hashicorp/boundary",
    consul: "https://github.com/hashicorp/consul",
    hcp: DEFAULT_GITHUB_LINK,
    nomad: "https://github.com/hashicorp/nomad",
    packer: "https://github.com/hashicorp/packer",
    sentinel: DEFAULT_GITHUB_LINK,
    terraform: "https://github.com/hashicorp/terraform",
    vagrant: "https://github.com/hashicorp/vagrant",
    vault: "https://github.com/hashicorp/vault",
    waypoint: "https://github.com/hashicorp/waypoint"
};
/**
 * Generates additional sidebar nav items for the Resources section. If an
 * `additional-sidebar-resources.json` file exists for a product in the
 * `src/content` directory, and it has the correct data structure, the specified
 * nav items will be appended to the Resources section.
 */ const generateAdditionalResources = (productSlug)=>{
    if (productSlug) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            return __webpack_require__(2967)(`./${productSlug}/additional-sidebar-resources.json`);
        } catch  {
            return [];
        }
    }
    return [];
};
/**
 * Given a product slug,
 * Return a link to the Tutorials Library with filters applied
 * that correspond to that product.
 */ function getTutorialLibraryUrl(productSlug) {
    const baseUrl = "/tutorials/library";
    if (!productSlug) {
        return baseUrl;
    }
    if (VALID_PRODUCT_SLUGS_FOR_FILTERING.includes(productSlug)) {
        return `${baseUrl}/?product=${productSlug}`;
    } else if (VALID_EDITION_SLUGS_FOR_FILTERING.includes(productSlug)) {
        return `${baseUrl}/?edition=${productSlug}`;
    } else {
        return baseUrl;
    }
}
/**
 * Given a product slug,
 * Return an array of resource links.
 *
 * If we have a corresponding certification program page to link to,
 * we return that single link item in an array.
 *
 * If the given product does not have a certifications page,
 * we return an empty array.
 */ function getCertificationsLink(productSlug) {
    // If this product does not have a certifications link, return an empty array
    const programSlug = certificationProgramSlugMap[productSlug];
    if (!programSlug) {
        return [];
    }
    // If this product does have a certifications link, return a single-item array
    const link = {
        title: "Certifications",
        href: `/certifications/${programSlug}`
    };
    return [
        link
    ];
}
/**
 * Generates the sidebar nav items for the Resources section of the sidebar.
 * Optionally accepts a Product slug for customization of links.
 */ const generate_resources_nav_items_generateResourcesNavItems = (productSlug)=>{
    const additionalResources = generateAdditionalResources(productSlug);
    return [
        {
            heading: "Resources"
        },
        {
            title: "Tutorial Library",
            href: getTutorialLibraryUrl(productSlug)
        },
        ...getCertificationsLink(productSlug),
        {
            title: "Community Forum",
            href: productSlug ? COMMUNITY_LINKS_BY_PRODUCT[productSlug] : DEFAULT_COMMUNITY_FORUM_LINK
        },
        {
            title: "Support",
            href: DEFAULT_SUPPORT_LINK
        },
        {
            title: "GitHub",
            href: productSlug ? GITHUB_LINKS_BY_PRODUCT_SLUG[productSlug] : DEFAULT_GITHUB_LINK
        },
        ...additionalResources
    ];
};


;// CONCATENATED MODULE: ./src/lib/generate-top-level-sub-nav-items.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Generates the top-level nav items to be rendered in various places in the
 * app, including `Sidebar`, the home page mobile menu, and the main nav H menu
 * that shows on non-home pages.
 */ const generate_top_level_sub_nav_items_generateTopLevelSubNavItems = ()=>{
    const productItems = [];
    Object.keys(productSlugsToNames).forEach((productSlug)=>{
        // Exclude Sentinel for now
        if (productSlug === "sentinel") {
            return;
        }
        const leadingIconName = productSlug;
        const title = productSlugsToNames[productSlug];
        const href = `/${productSlug}`;
        const navItem = {
            leadingIconName,
            title,
            href
        };
        productItems.push(navItem);
    });
    return [
        {
            leadingIconName: "home",
            title: "HashiCorp Developer",
            href: "/"
        },
        {
            divider: true
        },
        {
            heading: "Products"
        },
        ...productItems
    ];
};

;// CONCATENATED MODULE: ./src/components/sidebar/helpers/generate-top-level-sidebar-nav-data.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Generates the top-level website nav data for rendering in `Sidebar` as the
 * top-level of the mobile navigation experience.
 */ const generateTopLevelSidebarNavData = (productName)=>{
    const levelButtonProps = {
        levelDownButtonText: `${productName} Home`
    };
    const showFilterInput = false;
    const title = "Main Menu";
    return {
        levelButtonProps,
        menuItems: generateTopLevelSubNavItems(),
        showFilterInput,
        title
    };
};

;// CONCATENATED MODULE: ./src/components/sidebar/helpers/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 







;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-nav-list/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

function sidebar_nav_list_SidebarNavList({ children  }) {
    return /*#__PURE__*/ _jsx("ul", {
        className: s.navList,
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/chevron-left-16.tsx
var chevron_left_16 = __webpack_require__(7237);
;// CONCATENATED MODULE: ./src/components/standalone-link/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




const DEFAULT_COLOR_VARIANT = "primary";
const DEFAULT_SIZE_VARIANT = "medium";
const StandaloneLinkContents = ({ className , color , icon , iconPosition , inheritColor =false , size =DEFAULT_SIZE_VARIANT , text , textClassName  })=>{
    if (color && inheritColor) {
        developmentToast({
            color: ToastColor.warning,
            title: "Warning in `StandaloneLinkContents`",
            description: "`StandaloneLinkContents` does not accept both `color` and `inheritColor`; `inheritColor` takes precedence."
        });
    }
    const containerClasses = classNames(s.standaloneLinkContents, s[size], !inheritColor && s[color ?? DEFAULT_COLOR_VARIANT], className);
    const textClasses = classNames(s.text, textClassName);
    return /*#__PURE__*/ _jsxs("div", {
        className: containerClasses,
        children: [
            iconPosition === "leading" && icon,
            /*#__PURE__*/ _jsx("span", {
                className: textClasses,
                children: text
            }),
            iconPosition === "trailing" && icon
        ]
    });
};
const standalone_link_StandaloneLink = ({ ariaLabel , className , color =DEFAULT_COLOR_VARIANT , "data-heap-track": dataHeapTrack , download , href , icon , iconPosition , onClick , opensInNewTab =false , size =DEFAULT_SIZE_VARIANT , text , textClassName  })=>{
    const classes = classNames(s.standaloneLink, s[color], className);
    const rel = opensInNewTab ? "noreferrer noopener" : undefined;
    return /*#__PURE__*/ _jsx(Link, {
        "aria-label": ariaLabel,
        className: classes,
        "data-heap-track": `standalone-link ${dataHeapTrack ?? ""}`,
        download: download,
        href: href,
        onClick: onClick,
        rel: rel,
        opensInNewTab: opensInNewTab,
        children: /*#__PURE__*/ _jsx(StandaloneLinkContents, {
            icon: icon,
            iconPosition: iconPosition,
            inheritColor: true,
            size: size,
            text: text,
            textClassName: textClassName
        })
    });
};

/* harmony default export */ const standalone_link = ((/* unused pure expression or super */ null && (standalone_link_StandaloneLink)));

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-back-to-link/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



const sidebar_back_to_link_SidebarBackToLink = ({ text , href  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: s.root,
        children: /*#__PURE__*/ _jsx(StandaloneLink, {
            href: href,
            icon: /*#__PURE__*/ _jsx(IconChevronLeft16, {
                className: s.icon
            }),
            iconPosition: "leading",
            text: text,
            "data-heap-track": "sidebar-back-to-link"
        })
    });
};
/* harmony default export */ const sidebar_back_to_link = ((/* unused pure expression or super */ null && (sidebar_back_to_link_SidebarBackToLink)));

;// CONCATENATED MODULE: ./src/components/button/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



// eslint-disable-next-line react/display-name
const button_Button = /*#__PURE__*/ (/* unused pure expression or super */ null && (forwardRef(({ "aria-controls": ariaControls , "aria-describedby": ariaDescribedBy , "aria-expanded": ariaExpanded , "aria-label": ariaLabel , "aria-labelledby": ariaLabelledBy , className , color ="primary" , "data-heap-track": dataHeapTrack , disabled , form , icon , iconPosition ="leading" , id , isFullWidth , name , onClick , size ="medium" , text , type ="button"  }, ref)=>{
    const classes = classNames(s.root, s[size], s[color], {
        [s.fullWidth]: isFullWidth
    }, className);
    const hasIcon = !!icon;
    const hasText = !!text;
    const hasLabel = !!ariaLabel || !!ariaLabelledBy || !!ariaDescribedBy;
    const hasLeadingIcon = hasIcon && iconPosition === "leading";
    const hasTrailingIcon = hasIcon && iconPosition === "trailing";
    const isIconOnly = hasIcon && !hasText;
    if (!hasIcon && !hasText) {
        throw new Error("`Button` must have either `text` or an `icon` with accessible labels.");
    }
    if (isIconOnly && !hasLabel) {
        throw new Error("Icon-only `Button`s require an accessible label. Either provide the `text` prop or one of: `ariaLabel`, `ariaLabelledBy`, `ariaDescribedBy`.");
    }
    if (ariaLabel && ariaLabelledBy) {
        throw new Error("`Button` does not accept both `ariaLabel` and `ariaLabelledBy`. Only provide one or the other.");
    }
    return /*#__PURE__*/ _jsxs("button", {
        "aria-controls": ariaControls,
        "aria-describedby": ariaDescribedBy,
        "aria-expanded": ariaExpanded,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        className: classes,
        "data-heap-track": `button ${dataHeapTrack ?? ""}`,
        disabled: disabled,
        form: form,
        id: id,
        name: name,
        onClick: onClick,
        ref: ref,
        type: type,
        children: [
            hasLeadingIcon && icon,
            hasText && /*#__PURE__*/ _jsx("span", {
                className: s.text,
                children: text
            }),
            hasTrailingIcon && icon
        ]
    });
})));
/* harmony default export */ const components_button = ((/* unused pure expression or super */ null && (button_Button)));

;// CONCATENATED MODULE: ./src/components/sidebar/components/sidebar-mobile-controls/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 






/**
 * The base `Button` component used by both `LevelUpButton` and
 * `LevelDownButton`. Handles setting the `Button` props that are the same for
 * both buttons.
 */ const BaseControlButton = ({ className , icon , iconPosition , onClick , text  })=>{
    return /*#__PURE__*/ _jsx(Button, {
        className: className,
        color: "tertiary",
        icon: icon,
        iconPosition: iconPosition,
        onClick: onClick,
        text: text
    });
};
/**
 * The `Button` that handles moving the user "up" one nav data level in
 * `Sidebar`.
 *
 * Notes:
 *  - Always has a leading chevron-left icon.
 *  - Always displays on the lefthand side of the `Sidebar`.
 */ const LevelUpButton = ({ onClick , text  })=>{
    return /*#__PURE__*/ _jsx(BaseControlButton, {
        className: s.levelUpButton,
        icon: /*#__PURE__*/ _jsx(IconChevronLeft16, {}),
        iconPosition: "leading",
        onClick: onClick,
        text: text
    });
};
/**
 * The `Button` that handles moving the user "down" one nav data level in
 * `Sidebar`.
 *
 * Notes:
 *  - Always has a trailing chevron-right icon.
 *  - If rendered with `LevelUpButton`, displays on the righthand side of the
 *    `Sidebar`.
 *  - If rendered alone, displays on the lefthand side of the `Sidebar`.
 */ const LevelDownButton = ({ onClick , text  })=>{
    return /*#__PURE__*/ _jsx(BaseControlButton, {
        className: s.levelDownButton,
        icon: /*#__PURE__*/ _jsx(IconChevronRight16, {}),
        iconPosition: "trailing",
        onClick: onClick,
        text: text
    });
};
/**
 * Handles rendering either one or both of `LevelUpButton` and
 * `LevelDownButton`. It determines what to render by consuming data from
 * `SidebarNavDataContext` using the `useSidebarNavData` hook.
 */ const sidebar_mobile_controls_SidebarMobileControls = ({ levelUpButtonText , levelDownButtonText  })=>{
    const { hasManyLevels , isFirstLevel , isLastLevel , setCurrentLevel  } = useSidebarNavData();
    // Show `LevelUpButton` on all levels but the first one
    let levelUpButton;
    if (hasManyLevels && !isFirstLevel) {
        levelUpButton = /*#__PURE__*/ _jsx(LevelUpButton, {
            text: levelUpButtonText,
            onClick: ()=>setCurrentLevel((prevLevel)=>prevLevel - 1)
        });
    }
    // Show `LevelDownButton` on all levels but the last one
    let levelDownButton;
    if (hasManyLevels && !isLastLevel) {
        levelDownButton = /*#__PURE__*/ _jsx(LevelDownButton, {
            text: levelDownButtonText,
            onClick: ()=>setCurrentLevel((prevLevel)=>prevLevel + 1)
        });
    }
    const atTopLevel = !levelUpButton && !!levelDownButton;
    return /*#__PURE__*/ _jsxs("div", {
        className: classNames(s.root, {
            [s.rightAlign]: atTopLevel
        }),
        children: [
            levelUpButton,
            levelDownButton
        ]
    });
};
/* harmony default export */ const sidebar_mobile_controls = ((/* unused pure expression or super */ null && (sidebar_mobile_controls_SidebarMobileControls)));

;// CONCATENATED MODULE: ./src/components/sidebar/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ // Third-party imports



// Global imports











const sidebar_Sidebar = ({ backToLinkProps , children , levelButtonProps , menuItems , overviewItemHref , showFilterInput =true , title , visuallyHideTitle =false  })=>{
    const currentProduct = useCurrentProduct();
    const { shouldRenderMobileControls  } = useSidebarNavData();
    const currentPath = useCurrentPath({
        excludeHash: true,
        excludeSearch: true
    });
    const [filterValue, setFilterValue] = useState("");
    const { itemsWithMetadata  } = useMemo(()=>addNavItemMetaData(currentPath, menuItems), [
        currentPath,
        menuItems
    ]);
    let backToElement;
    if (shouldRenderMobileControls && levelButtonProps) {
        backToElement = /*#__PURE__*/ _jsx(SidebarMobileControls, {
            levelUpButtonText: levelButtonProps.levelUpButtonText,
            levelDownButtonText: levelButtonProps.levelDownButtonText
        });
    } else if (backToLinkProps) {
        const { text , href  } = backToLinkProps;
        backToElement = /*#__PURE__*/ _jsx("div", {
            className: s.backToLinkWrapper,
            children: /*#__PURE__*/ _jsx(SidebarBackToLink, {
                text: text,
                href: href
            })
        });
    }
    let sidebarFilterInput;
    if (showFilterInput) {
        sidebarFilterInput = /*#__PURE__*/ _jsx("div", {
            className: classNames(s.filterInputWrapper, {
                [s["filterInputWrapper--mobile"]]: shouldRenderMobileControls
            }),
            children: /*#__PURE__*/ _jsx(FilterInput, {
                value: filterValue,
                onChange: setFilterValue,
                placeholder: "Filter sidebar"
            })
        });
    }
    let overviewItem;
    if (overviewItemHref && !filterValue) {
        overviewItem = /*#__PURE__*/ _jsx(SidebarNavLinkItem, {
            item: {
                href: overviewItemHref,
                title: "Overview",
                isActive: overviewItemHref === currentPath
            }
        });
    }
    let sidebarContent;
    if (children) {
        sidebarContent = children;
    } else {
        const filteredMenuItems = getFilteredNavItems(itemsWithMetadata, filterValue);
        sidebarContent = /*#__PURE__*/ _jsx(SidebarNavList, {
            children: filteredMenuItems.map((item, i)=>{
                const key = `${item.id}-${i}`;
                return /*#__PURE__*/ _jsx(SidebarNavMenuItem, {
                    item: item
                }, key);
            })
        });
    }
    return /*#__PURE__*/ _jsxs("div", {
        className: s.sidebar,
        children: [
            backToElement,
            sidebarFilterInput,
            /*#__PURE__*/ _jsxs("nav", {
                "aria-labelledby": SIDEBAR_LABEL_ID,
                className: s.nav,
                id: SIDEBAR_NAV_ELEMENT_ID,
                children: [
                    /*#__PURE__*/ _jsx("div", {
                        className: visuallyHideTitle ? "g-screen-reader-only" : undefined,
                        children: /*#__PURE__*/ _jsx(SidebarTitleHeading, {
                            text: title,
                            id: SIDEBAR_LABEL_ID
                        })
                    }),
                    /*#__PURE__*/ _jsx(SidebarSkipToMainContent, {}),
                    overviewItem,
                    sidebarContent,
                    /*#__PURE__*/ _jsx(SidebarHorizontalRule, {}),
                    /*#__PURE__*/ _jsx(SidebarNavList, {
                        children: generateResourcesNavItems(currentProduct?.slug).map((item, index)=>// eslint-disable-next-line react/no-array-index-key
                            /*#__PURE__*/ _jsx(SidebarNavMenuItem, {
                                item: item
                            }, index))
                    })
                ]
            })
        ]
    });
};
/* harmony default export */ const sidebar = ((/* unused pure expression or super */ null && (sidebar_Sidebar)));

;// CONCATENATED MODULE: external "@tanstack/react-query"
const react_query_namespaceObject = require("@tanstack/react-query");
;// CONCATENATED MODULE: external "next-auth/react"
const react_namespaceObject = require("next-auth/react");
// EXTERNAL MODULE: ./node_modules/@hashicorp/react-consent-manager/index.tsx + 14 modules
var react_consent_manager = __webpack_require__(67173);
// EXTERNAL MODULE: ./node_modules/@hashicorp/react-consent-manager/util/cookies.js
var cookies = __webpack_require__(82207);
// EXTERNAL MODULE: ./src/types/auth.ts
var auth = __webpack_require__(84324);
;// CONCATENATED MODULE: ./src/hooks/use-authentication/helpers/make-sign-in.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Creates a minimal wrapper around next-auth/react's `signIn` function. Its
 * purpose is to handle invoking the wrapped function with default values.
 *
 * https://next-auth.js.org/getting-started/client#signin
 */ const make_sign_in_makeSignIn = ({ routerPath  })=>{
    return (provider = DEFAULT_PROVIDER_ID, options = {})=>{
        const { callbackUrl =routerPath , redirect =true  } = options;
        return signIn(provider, {
            callbackUrl,
            redirect
        });
    };
};


;// CONCATENATED MODULE: ./src/hooks/use-authentication/helpers/make-sign-out.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * A minimal wrapper around next-auth/react's `signOut` function. Purpose is to
 * handle invoking the wrapped function with a default value.
 *
 * https://next-auth.js.org/getting-started/client#signout
 */ const make_sign_out_makeSignOut = ({ routerPath  })=>{
    return (options = {})=>{
        const { callbackUrl =routerPath === "/profile/bookmarks" ? "/" : routerPath , redirect =true  } = options;
        return signOut({
            callbackUrl,
            redirect
        });
    };
};


;// CONCATENATED MODULE: ./src/hooks/use-authentication/helpers/sign-up.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * A function for invoking the sign up flow for an auth provider.
 */ const sign_up_signUp = (provider = DEFAULT_PROVIDER_ID, options = {}, authParams = {})=>{
    const { screen_hint ="signup" , ...restParams } = authParams;
    return signIn(provider, options, {
        screen_hint,
        ...restParams
    });
};


;// CONCATENATED MODULE: ./src/hooks/use-authentication/helpers/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




;// CONCATENATED MODULE: ./src/lib/analytics.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ /**
 * A segment analytics plugin to log out calls to track in a structured way. Includes the full event payload
 * in a collapsed console group for further inspection, without interaction the event name and event properties
 * are visible.
 */ const AnalyticsPluginEventLogger = {
    name: "Event Logger",
    version: "0.1.0",
    type: "after",
    track: (ctx)=>{
        console.groupCollapsed("%ctrack", "color:white;background:green;border-radius:4px;padding:2px 4px;", ctx.event.event, ctx.event.properties);
        console.log(ctx.event);
        console.groupEnd();
        return ctx;
    },
    load: ()=>Promise.resolve(),
    isLoaded: ()=>true
};
/**
 * Register the event logger plugin for track event logging during development.
 */ const makeDevAnalyticsLogger = ()=>{
    if (false) {}
};
/**
 * Determines whether or not `window.analytics.track` can be invoked.
 */ const canTrackAnalytics = ()=>{
    return  true && window.analytics && window.analytics.track && typeof window.analytics.track === "function";
};
/**
 * Invokes `window.analytics.track` if it is able to be invoked.
 */ const safeAnalyticsTrack = (eventName, properties)=>{
    if (canTrackAnalytics()) {
        window.analytics.track(eventName, properties);
    }
};
/**
 * Determines whether or not `window.analytics.user` can be invoked.
 */ const analytics_canAnalyzeUser = ()=>{
    return  true && !!window.analytics && !!window.analytics.user && typeof window.analytics.user === "function";
};
function safeGetSegmentAnonymousId() {
    if (analytics_canAnalyzeUser()) {
        return window.analytics.user().anonymousId();
    } else {
        return null;
    }
}
function analytics_safeGetSegmentId() {
    if (analytics_canAnalyzeUser()) {
        return window.analytics.user().id();
    } else {
        return null;
    }
}
/**
 * Handles tracking the Download event in the same format it was tracked
 * previously on .io sites (excluding the `category` and `label` properties).
 *
 * Important notes:
 *  - Properties are defined in `analytics/spec/events/product_downloaded.yaml`
 *  - `prettyOSName` examples: "macOS", "Windows", "Linux", "FreeBSD", "NetBSD",
 *    "OpenBSD", "Solaris"
 *  - `architecture` will have it's first character capitalized automatically
 *
 * Based off `@hashicorp/react-product-downloads-page`'s `trackDownload`:
 * https://github.com/hashicorp/react-components/blob/d6eba7971bbbf7c58cf3cc110f5b7b423e3cd27c/packages/product-download-page/utils/downloader.ts#L115-L134
 */ const trackProductDownload = ({ architecture , prettyOSName , productSlug , version  })=>{
    // Ensure the `architecture` property has the correct casing
    const lowercasedArchitectureName = architecture.toLowerCase();
    const casedArchitectureName = lowercasedArchitectureName.charAt(0).toUpperCase() + lowercasedArchitectureName.slice(1);
    // Track the Download event
    safeAnalyticsTrack("Download", {
        architecture: casedArchitectureName,
        operating_system: prettyOSName,
        product: productSlug,
        version
    });
};


;// CONCATENATED MODULE: ./src/hooks/use-authentication/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 







const use_authentication_DEFAULT_PROVIDER_ID = auth/* ValidAuthProviderId.CloudIdp */.I.CloudIdp;
/**
 * Hook for consuming user, session, and authentication state. Sources all data
 * from next-auth/react's `useSession` hook.
 *
 * https://next-auth.js.org/getting-started/client#usesession
 */ const use_authentication_useAuthentication = (options = {})=>{
    // Get router path for `signIn` and `signOut` `callbackUrl`s
    const router = useRouter();
    // Set up memoized `signIn` and `signOut` callbacks
    const signIn = useMemo(()=>makeSignIn({
            routerPath: router.asPath
        }), [
        router.asPath
    ]);
    const signOut = useMemo(()=>makeSignOut({
            routerPath: router.asPath
        }), [
        router.asPath
    ]);
    // Get option properties from `options` parameter
    const { isRequired =false , onUnauthenticated =()=>signIn()  } = options;
    // Pull data and status from next-auth's hook, and pass options
    const { data , status  } = useSession({
        required: isRequired,
        onUnauthenticated
    });
    // Deriving booleans about auth state
    const isLoading = status === "loading";
    const isAuthenticated = status === "authenticated" && data?.error !== AuthErrors.RefreshAccessTokenError // if we are in an errored state, treat as unauthenticated
    ;
    const preferencesLoaded = preferencesSavedAndLoaded();
    /**
	 * Force sign out to hopefully resolve the error. The user is signed out
	 * to prevent unwanted looping of requesting an expired refresh token
	 *
	 * https://next-auth.js.org/tutorials/refresh-token-rotation#client-side
	 */ useEffect(()=>{
        if (data?.error === AuthErrors.RefreshAccessTokenError) {
            signOut();
        }
    }, [
        data?.error,
        signOut
    ]);
    // We accept consent manager on the user's behalf. As per Legal & Compliance,
    // signing-in means a user is accepting our privacy policy and so we can
    // enable tracking. Should only be ran if not already set & loaded.
    useEffect(()=>{
        if (isAuthenticated && !preferencesLoaded) {
            saveAndLoadAnalytics({
                loadAll: true
            });
        }
    }, [
        isAuthenticated,
        preferencesLoaded
    ]);
    // Separating user and session data
    let session, user;
    if (isAuthenticated) {
        session = {
            ...data
        };
        user = data.user;
        delete session.user;
        const segmentUserId = safeGetSegmentId();
        if (canAnalyzeUser() && segmentUserId !== session.id) {
            window.analytics?.identify(session.id, {
                email: user.email,
                devPortalSignUp: true
            });
        }
    }
    // Return everything packaged up in an object
    return {
        isAuthenticated,
        isLoading,
        session,
        signIn,
        signOut,
        signUp,
        user
    };
};
/* harmony default export */ const use_authentication = ((/* unused pure expression or super */ null && (use_authentication_useAuthentication)));

;// CONCATENATED MODULE: ./src/lib/learn-client/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ function getFetch() {
    // Note: purposely doing a conditional require here so that `@vercel/fetch` is not included in the client bundle
    if (true) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const createFetch = __webpack_require__(33666);
        return createFetch();
    }
    return window.fetch;
}
// some of our reqs occur in a node env where fetch
// isn't defined e.g. algolia search script
const fetch = getFetch();
function learn_client_get(path, token) {
    const options = {
        method: "GET"
    };
    // if the req needs to be auth'd, add the bearer token
    if (token) {
        options.headers = {
            Authorization: `Bearer ${token}`
        };
    }
    return fetch(`${"https://ycmsw3yg4a.us-east-1.awsapprunner.com"}${path}`, options);
}
function learn_client_put(path, token, bodyJson) {
    return fetch(`${"https://ycmsw3yg4a.us-east-1.awsapprunner.com"}${path}`, {
        method: "PUT",
        headers: {
            Authorization: `Bearer ${token}`,
            "Content-type": "application/json"
        },
        body: JSON.stringify(bodyJson)
    });
}
function learn_client_post(path, token, bodyJson = {}) {
    return fetch(`${"https://ycmsw3yg4a.us-east-1.awsapprunner.com"}${path}`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${token}`,
            "Content-type": "application/json"
        },
        body: JSON.stringify(bodyJson)
    });
}
function destroy(path, token) {
    return fetch(`${"https://ycmsw3yg4a.us-east-1.awsapprunner.com"}${path}`, {
        method: "DELETE",
        headers: {
            Authorization: `Bearer ${token}`
        }
    });
}
async function learn_client_toError(errorResponse) {
    let json;
    try {
        json = await errorResponse.json();
    } catch (err) {
    // Do nothing if the response is not json
    }
    return new Error(`${errorResponse.status} ${errorResponse.statusText}${json?.error ? ` - ${json.error}` : ""}`);
}

;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/get-tutorial-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Fetches progress on a single tutorial.
 *
 * https://digital-api-specs.vercel.app/learn#tag/Collection-Tutorial-Progress/paths/~1collections~1{collection_id}~1tutorials~1{tutorial_id}~1progress/get
 */ const get_tutorial_progress_getTutorialProgress = async ({ accessToken , tutorialId , collectionId  })=>{
    // Build the API route to make a request to
    const requestRoute = getTutorialProgressRoute({
        collectionId,
        tutorialId
    });
    // Make the request
    const requestResult = await get(requestRoute, accessToken);
    // Return null if the request status is 404
    if (requestResult.status === 404) {
        return null;
    }
    // Return data as JSON if result is OK
    if (requestResult.ok) {
        const { result  } = await requestResult.json();
        return result;
    }
    // Throw an error if result is not OK
    const error = await toError(requestResult);
    throw error;
};


;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/create-tutorial-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Creates a tutorial progress record.
 *
 * https://digital-api-specs.vercel.app/learn#tag/Collection-Tutorial-Progress/paths/~1collections~1{collection_id}~1tutorials~1{tutorial_id}~1progress/post
 */ const createTutorialProgress = async ({ accessToken , tutorialId , collectionId , completePercent  })=>{
    // Build the API route to make a request to
    const requestRoute = getTutorialProgressRoute({
        collectionId,
        tutorialId
    });
    // Make the request
    const requestResult = await post(requestRoute, accessToken, {
        complete_percent: completePercent
    });
    // Return data as JSON if result is OK
    if (requestResult.ok) {
        const { result  } = await requestResult.json();
        return result;
    }
    // Throw an error if result is not OK
    const error = await toError(requestResult);
    throw error;
};


;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/update-tutorial-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Updates a tutorial progress record.
 *
 * https://digital-api-specs.vercel.app/learn#tag/Collection-Tutorial-Progress/paths/~1collections~1{collection_id}~1tutorials~1{tutorial_id}~1progress/put
 */ const update_tutorial_progress_updateTutorialProgress = async ({ accessToken , tutorialId , collectionId , completePercent  })=>{
    // Build the API route to make a request to
    const requestRoute = getTutorialProgressRoute({
        collectionId,
        tutorialId
    });
    // Make the request
    const requestResult = await put(requestRoute, accessToken, {
        complete_percent: completePercent
    });
    // Return null if the request status is 404
    if (requestResult.status === 404) {
        return null;
    }
    // Return data as JSON if result is OK
    if (requestResult.ok) {
        const { result  } = await requestResult.json();
        return result;
    }
    // Throw an error if result is not OK
    const error = await toError(requestResult);
    throw error;
};


;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/formatting.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Convert from API's complete_percent to the TutorialProgressStatus enum.
 *
 * This is necessary as in the context of Dev Dot, we want the label,
 * but in the context of the Learn API, we want complete_percent.
 */ function formatting_progressPercentToStatus(percent) {
    if (percent === "100") {
        return TutorialProgressStatus.complete;
    } else if (percent === "0") {
        return TutorialProgressStatus.visited;
    } else {
        return TutorialProgressStatus.in_progress;
    }
}
/**
 * Convert from the TutorialProgressStatus enum to the API complete_percent
 *
 * This is necessary as in the context of Dev Dot, we want the label,
 * but in the context of the Learn API, we want complete_percent.
 */ function formatting_progressStatusToPercent(progressState) {
    if (progressState === TutorialProgressStatus.complete) {
        return TutorialProgressPercent.OneHundred;
    } else if (progressState === TutorialProgressStatus.in_progress) {
        return TutorialProgressPercent.Fifty;
    } else {
        return TutorialProgressPercent.Zero;
    }
}
/**
 * Map TutorialProgressStatus to text for display use.
 */ const progressLabels = {
    visited: "Visited",
    in_progress: "In progress",
    complete: "Complete"
};
/**
 * Given a TutorialProgressStatus,
 * Returns text representing the status suitable for display.
 */ function progressStatusToLabel(progressState) {
    return progressLabels[progressState];
}
/**
 * Map TutorialProgressStatus to text for screen reader use.
 */ const progressAriaLabels = {
    visited: "Tutorial is visited.",
    in_progress: "Tutorial is in progress.",
    complete: "Tutorial is complete."
};
/**
 * Given a TutorialProgressStatus,
 * Returns text representing the status suitable for screen reader use.
 */ function progressStatusToAriaLabel(progressState) {
    return progressAriaLabels[progressState];
}

;// CONCATENATED MODULE: external "query-string"
const external_query_string_namespaceObject = require("query-string");
;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/get-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


/**
 * Fetches tutorial progress records for the current user.
 * If successful, returns an array of progress objects.
 * Otherwise throws an error.
 *
 * Accepts optional arrays of `tutorialIds` and `collectionIds`.
 * When either of these are provided, we return all progress records
 * that match either:
 * - any one of the provided `tutorialIds`
 * - any one of the provided `collectionIds`
 *
 * https://digital-api-specs.vercel.app/learn#tag/Progress/paths/~1progress/get
 */ const get_progress_getProgress = async ({ accessToken , tutorialIds , collectionIds  })=>{
    // Add query params to the URL, if applicable
    let url = PROGRESS_API_ROUTE;
    const qs = queryString.stringify({
        tutorialIds,
        collectionIds
    }, {
        arrayFormat: "comma"
    });
    if (qs !== "") {
        url += `?${qs}`;
    }
    // Make the GET request
    const requestResult = await get(url, accessToken);
    // Return data as JSON if result is OK
    if (requestResult.ok) {
        const { result  } = await requestResult.json();
        return result;
    }
    // Throw an error if result is not OK
    const error = await toError(requestResult);
    throw error;
};


;// CONCATENATED MODULE: ./src/lib/learn-client/api/progress/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ // Fetch

// Create

// Update

// Formatting

/**
 * Used in get-all-progress.
 */ const progress_PROGRESS_API_ROUTE = "/progress";



;// CONCATENATED MODULE: ./src/hooks/use-has-waited-for-query.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * Hook to return whether we've attempted a particular query yet.
 *
 * This is intended for use in individual progress queries,
 * in order to check whether a relevant batch query has been attempted.
 *
 * Why? We want to give the batch query a chance to prime the cache
 * before firing off individual queries. So, we likely want to disable
 * individual queries until a batch query has been attempted at least once.
 */ function use_has_waited_for_query_useHasWaitedForQuery(queryKey) {
    /**
	 * The our batch query state from the queryClient
	 */ const queryClient = useQueryClient();
    const queryStatus = queryClient.getQueryState(queryKey, {
        exact: false
    });
    /**
	 * We've made an attempt if:
	 * - some matching query exists (queryStatus is NOT undefined)
	 * - that matching query has updated or failed at least once
	 */ let hasTargetQueryAttempt;
    const hasBatchQuery = typeof queryStatus !== "undefined";
    if (hasBatchQuery) {
        const { dataUpdateCount , fetchFailureCount  } = queryStatus;
        hasTargetQueryAttempt = dataUpdateCount > 0 || fetchFailureCount > 0;
    } else {
        hasTargetQueryAttempt = true;
    }
    return hasTargetQueryAttempt;
}

;// CONCATENATED MODULE: ./src/hooks/progress/use-collection-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 





/**
 * Handles checking if there is progress for the given `collectionId`.
 */ function use_collection_progress_useCollectionProgress({ collectionId  }) {
    /**
	 * Get the current user's access token, and the batch query status.
	 * We enable the query only if:
	 * - an accessToken is present
	 * - a batch query, if one exists, has been attempted
	 */ const { isAuthenticated , session  } = useAuthentication();
    const accessToken = session?.accessToken;
    const hasWaitedForBatchQuery = useHasWaitedForQuery([
        PROGRESS_BATCH_QUERY_ID
    ]);
    const enabled = !!accessToken && isAuthenticated && hasWaitedForBatchQuery;
    // Fetch progress records by `collectionId`
    const { data , ...restQueryResult } = useQuery([
        COLLECTION_PROGRESS_SINGLE_QUERY_ID,
        collectionId
    ], useCallback(()=>getProgress({
            accessToken,
            collectionIds: [
                collectionId
            ]
        }), [
        accessToken,
        collectionId
    ]), {
        enabled
    });
    return {
        data,
        ...restQueryResult
    };
}


;// CONCATENATED MODULE: ./src/hooks/progress/use-progress-batch-query/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



/**
 * Fetches progress records for:
 * - any provided `tutorials` (specific `{ tutorialId, collectionId }` records)
 * - any provided `collections` (any matching `collectionId` records)
 *
 * Uses these records to set query data for:
 * - the provided `tutorials`
 * - the provided `collections`
 *
 * Intended for use at the view level, to prime all known progress queries
 * within a specific view.
 */ function useProgressBatchQuery({ tutorials =[] , collections =[]  }) {
    /**
	 * Get unique tutorial IDs, these will be used to fetch records.
	 *
	 * Note that the API supports fetching in batch by tutorialId OR collectionId.
	 * We aren't able to fetch only specific tutorialId + collectionId
	 * combinations, even though that's often what we want.
	 */ const tutorialIds = Array.from(new Set(tutorials.map((entry)=>entry.tutorialId)));
    /**
	 * Get unique requested collection IDs
	 */ const collectionIds = Array.from(new Set(collections));
    // Get the current Query Client
    const queryClient = useQueryClient();
    // Get the current user's access token
    const { isAuthenticated , session  } = useAuthentication();
    const accessToken = session?.accessToken;
    /**
	 * After a successful query, prime the requested
	 * tutorial & collection progress queries.
	 */ const onSuccess = (data)=>{
        /**
		 * Iterate over the requested tutorial entries, setting query data for each.
		 *
		 * Iterating this way allows us to set `null` for tutorial queries where
		 * we know we don't have progress data. If we only set query data for
		 * returned `data` (ie tutorials with progress records), then we'd see
		 * redundant 404 re-fetching when querying those tutorials individually.
		 */ tutorials.forEach((entry)=>{
            const { tutorialId , collectionId  } = entry;
            const matchedRecords = data.filter((record)=>record.tutorial_id == tutorialId && record.collection_id == collectionId);
            const matchedRecord = matchedRecords.length > 0 ? matchedRecords[0] : null;
            queryClient.setQueryData([
                TUTORIAL_PROGRESS_SINGLE_QUERY_ID,
                tutorialId,
                collectionId
            ], matchedRecord // Note: may be null, for tutorials with no progress
            );
        });
        /**
		 * Iterate over the requested collection entries,
		 * setting query data for each.
		 */ collections.forEach((collectionId)=>{
            const matchedRecords = data.filter((record)=>record.collection_id == collectionId);
            queryClient.setQueryData([
                COLLECTION_PROGRESS_SINGLE_QUERY_ID,
                collectionId
            ], matchedRecords // Note: may be [], for collections with no progress
            );
        });
    };
    /**
	 * Fetch all progress records.
	 *
	 * Note that filtering will return any record that matches
	 * any provided `tutorialId`, OR any provided `collectionId`.
	 */ const { data , ...restQueryResult } = useQuery([
        PROGRESS_BATCH_QUERY_ID,
        {
            tutorialIds
        }
    ], ()=>getProgress({
            accessToken,
            tutorialIds,
            collectionIds
        }), {
        enabled: isAuthenticated && !!accessToken,
        onSuccess
    });
    /**
	 * Return the queried data.
	 *
	 * Note: it may not be practical to use data from this query, as passing
	 * it to the necessary components would likely require prop drilling.
	 *
	 * Instead, the intent is for this query to be used at the view level
	 * to prime query data with a single API request. Then, when components
	 * in the view make individual queries, they'll hit the cache rather
	 * than causing a deluge of individual requests.
	 */ return {
        data,
        ...restQueryResult
    };
}


;// CONCATENATED MODULE: ./src/hooks/progress/use-tutorial-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 





/**
 * Handles checking if there is a progress for the given
 * `tutorialId` & `collectionId` combination.
 */ const use_tutorial_progress_useTutorialProgress = ({ tutorialId , collectionId  })=>{
    /**
	 * Get the current user's access token, and the batch query status.
	 * We enable the query only if:
	 * - an accessToken is present
	 * - a batch query, if one exists, has been attempted
	 */ const { isAuthenticated , session  } = useAuthentication();
    const accessToken = session?.accessToken;
    const hasWaitedForBatchQuery = useHasWaitedForQuery([
        PROGRESS_BATCH_QUERY_ID
    ]);
    const enabled = isAuthenticated && !!accessToken && hasWaitedForBatchQuery;
    /**
	 * Fetch the progress record, if any, for the specified tutorialId
	 * in the specific collectionId context.
	 */ const { data: tutorialProgressStatus , ...restQueryResult } = useQuery([
        TUTORIAL_PROGRESS_SINGLE_QUERY_ID,
        tutorialId,
        collectionId
    ], useCallback(()=>getTutorialProgress({
            accessToken,
            tutorialId,
            collectionId
        }), [
        accessToken,
        tutorialId,
        collectionId
    ]), {
        enabled,
        select: (data)=>{
            /**
				 * Data may be null, if a progress record does not exist
				 * for this tutorialId + collectionId combination.
				 *
				 * We pass this on to the query consumer, as they may need
				 * to know whether the record exists or not.
				 */ if (data == null) {
                return null;
            }
            return progressPercentToStatus(data.complete_percent);
        }
    });
    return {
        tutorialProgressStatus,
        ...restQueryResult
    };
};


;// CONCATENATED MODULE: ./src/hooks/progress/use-tutorial-progress-mutations/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




/**
 * Mutate tutorial progress.
 *
 * Returns `createTutorialProgress` and `updateTutorialProgress`
 * mutation functions.
 *
 * Each of these functions accepts a single object argument:
 * `{ tutorialId, collectionId, completePercent }` (and, optionally, `options`)
 * and creates or updates the tutorial with the provided completePercent.
 */ const use_tutorial_progress_mutations_useTutorialProgressMutations = ()=>{
    const queryClient = useQueryClient();
    const { session  } = useAuthentication();
    const accessToken = session?.accessToken;
    /**
	 * When a mutation is successful, we set the associated query data.
	 * We also invalidate queries that might involve related data.
	 */ const makeOnMutationSuccess = ()=>{
        return (data, mutationVariables)=>{
            // Destructure the variables we need to update tutorial query data
            const { tutorialId , collectionId  } = mutationVariables;
            queryClient.setQueryData([
                TUTORIAL_PROGRESS_SINGLE_QUERY_ID,
                tutorialId,
                collectionId
            ], data);
            /**
			 * Invalidate related collection progress
			 *
			 * 📌 FUTURE TODO: perhaps ideally any POST, PUT, or even DELETE
			 * would return collection progress data as well as the mutated
			 * tutorial progress data? This way, rather than invalidating the
			 * collection query here, we could set it directly.
			 */ queryClient.invalidateQueries([
                COLLECTION_PROGRESS_SINGLE_QUERY_ID,
                collectionId
            ]);
        };
    };
    /**
	 * Mutation to create tutorial progress.
	 */ const createTutorialProgressMutation = useMutation(createTutorialProgressApi, {
        onSuccess: makeOnMutationSuccess()
    });
    /**
	 * Function to create tutorial progress.
	 *
	 * Note: The createTutorialProgress function needs to update when the
	 * accessToken or onSuccess option of createTutorialProgressMutation changes.
	 * We wrap this in useCallback to prevent more updates than necessary.
	 */ const createTutorialProgress = useCallback((args)=>{
        const { tutorialId , collectionId , completePercent , options  } = args;
        createTutorialProgressMutation.mutate({
            accessToken,
            tutorialId,
            collectionId,
            completePercent
        }, options);
    }, [
        createTutorialProgressMutation,
        accessToken
    ]);
    /**
	 * Mutation to update tutorial progress.
	 */ const updateTutorialProgressMutation = useMutation(updateTutorialProgressApi, {
        onSuccess: makeOnMutationSuccess()
    });
    /**
	 * Function to update tutorial progress.
	 *
	 * Note: as with createTutorialProgress,
	 * we wrap this in useCallback to prevent more updates than necessary.
	 */ const updateTutorialProgress = useCallback((args)=>{
        const { tutorialId , collectionId , completePercent , options  } = args;
        updateTutorialProgressMutation.mutate({
            accessToken,
            tutorialId,
            collectionId,
            completePercent
        }, options);
    }, [
        updateTutorialProgressMutation,
        accessToken
    ]);
    /**
	 * Consumers likely only want to perform calculations in preparation to
	 * run these mutations if status is "idle" or "success". Otherwise,
	 * attempt to run the mutation may result in a continuous loop.
	 */ const { status: createStatus  } = createTutorialProgressMutation;
    const { status: updateStatus  } = updateTutorialProgressMutation;
    const readyStatuses = [
        "idle",
        "success"
    ];
    const isReady = readyStatuses.includes(createStatus) && readyStatuses.includes(updateStatus);
    return {
        createTutorialProgress,
        updateTutorialProgress,
        isReady
    };
};


;// CONCATENATED MODULE: external "react-intersection-observer"
const external_react_intersection_observer_namespaceObject = require("react-intersection-observer");
;// CONCATENATED MODULE: ./src/hooks/progress/use-tutorial-progress-refs/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


// Tutorial progress utilities



// Types

/**
 * Given a tutorialId and collectionId,
 * Return two refs in an object, { startRef, endRef },
 * which can be placed on elements to track tutorial progress.
 *
 * On initial load, and when visibility of these refs changes,
 * we recalculate progress, and update with any forward progress.
 *
 * If the endRef element is within the viewport,
 * which means we're close to the bottom of the page,
 * the tutorial will be marked as `complete` (100 percent).
 *
 * If the startRef element is not within the viewport,
 * which means we've scrolled at least partway down the page,
 * the tutorial will be marked as `in_progress` (50 percent).
 *
 * Otherwise, the tutorial will be marked as `visited` (0 percent).
 *
 */ function useTutorialProgressRefs({ tutorialId , collectionId  }) {
    // We shouldn't try to update progress unless we're authenticated
    const { isAuthenticated  } = useAuthentication();
    // We need to know if progress exists, to know whether to "create" or "update"
    const { tutorialProgressStatus  } = useTutorialProgress({
        tutorialId,
        collectionId
    });
    // We'll use "create" or "update" progress using these `react-query` mutations
    const tutorialProgressMutations = useTutorialProgressMutations();
    // We use refs from `react-intersection-observer` to track progress.
    const [startRef, startInView, startEntry] = useInView({
        initialInView: true
    });
    const [endRef, endInView, endEntry] = useInView();
    /**
	 * This effect runs often, but it seems necessary to ensure progress
	 * gets tracked as things like the authenticated state changes.
	 *
	 * We bail early in many cases, and we avoid downgrading progress,
	 * so this effect only results in meaningful mutations a small percent
	 * of the time.
	 */ useEffect(()=>{
        /**
		 * Exit early if any conditions exist which would make it a bad idea to
		 * try to update progress. See canUpdateTutorialProgress for details.
		 */ if (!canUpdateTutorialProgress({
            startEntry,
            endEntry,
            tutorialId,
            collectionId,
            isAuthenticated,
            tutorialProgressStatus,
            tutorialProgressMutations
        })) {
            return;
        }
        /**
		 * Determine the new progress state, which we'll then update
		 * - 'complete' (100%) if the end ref is visible
		 * - 'in_progress' (50%) if the start ref is no longer visible
		 * - 'visited' (0%) in all other cases
		 */ let newProgressStatus;
        if (endInView) {
            newProgressStatus = TutorialProgressStatus.complete;
        } else if (!startInView) {
            newProgressStatus = TutorialProgressStatus.in_progress;
        } else {
            newProgressStatus = TutorialProgressStatus.visited;
        }
        /**
		 * If we have positive progress, or need to record initial progress,
		 * then we create or update our progress (formatted as percent for the API).
		 *
		 * Note that we don't ever downgrade the percent value of progress.
		 */ const existingPercent = progressStatusToPercent(tutorialProgressStatus);
        const newPercent = progressStatusToPercent(newProgressStatus);
        const hasPositiveProgress = parseInt(newPercent) > parseInt(existingPercent);
        // We won't see positive progress initially (0 > 0 == false)
        const needsInitialProgress = tutorialProgressStatus === null;
        if (needsInitialProgress || hasPositiveProgress) {
            // Update progress, either with a "create" or "update" mutation
            updateTutorialProgress({
                tutorialId,
                collectionId,
                tutorialProgressMutations,
                needsInitialProgress,
                completePercent: newPercent
            });
        }
    }, [
        // Tutorial and collection IDs, these change on client-side navigation
        tutorialId,
        collectionId,
        // Start and end refs
        startInView,
        endInView,
        endEntry,
        startEntry,
        // Authentication
        isAuthenticated,
        // Queried status for this tutorial, informs "create" vs "update"
        tutorialProgressStatus,
        // Result of useTutorialProgressMutations
        tutorialProgressMutations
    ]);
    return {
        startRef,
        endRef
    };
}

;// CONCATENATED MODULE: ./src/hooks/progress/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ /**
 * Constants
 */ const progress_PROGRESS_BATCH_QUERY_ID = "progressBatch";
const progress_TUTORIAL_PROGRESS_SINGLE_QUERY_ID = "tutorialProgress";
const progress_COLLECTION_PROGRESS_SINGLE_QUERY_ID = "collectionProgress";
/**
 * Hooks & Types
 */ 





;// CONCATENATED MODULE: ./src/components/button-link/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



/**
 * _Note WIP Component_
 * this button link component should mimic the design system options
 * outlined in `Button` component. This is a WIP implementation and should be
 * expanded upon. It currently renders a theme colors and sizes, with styles
 * copied from `Button`.
 **/ const button_link_ButtonLink = ({ "aria-label": ariaLabel , "data-heap-track": dataHeapTrack , color ="primary" , href , icon , iconPosition ="leading" , opensInNewTab =false , size ="medium" , text , className , onClick  })=>{
    const hasIcon = !!icon;
    const hasText = !!text;
    const hasLabel = !!ariaLabel;
    const hasLeadingIcon = hasIcon && iconPosition === "leading";
    const hasTrailingIcon = hasIcon && iconPosition === "trailing";
    const isIconOnly = hasIcon && !hasText;
    if (!hasIcon && !hasText) {
        throw new Error("`ButtonLink` must have either `text` or an `icon` with accessible labels.");
    }
    if (isIconOnly && !hasLabel) {
        throw new Error("Icon-only `ButtonLink`s require an accessible label. Either provide the `text` prop, or `ariaLabel`.");
    }
    return /*#__PURE__*/ _jsx(Link, {
        "aria-label": ariaLabel,
        className: classNames(s.root, s[size], s[color], className),
        "data-heap-track": `button-link ${dataHeapTrack ?? ""}`,
        href: href,
        onClick: onClick,
        opensInNewTab: opensInNewTab,
        rel: opensInNewTab ? "noreferrer noopener" : undefined,
        children: /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                hasLeadingIcon && icon,
                hasText ? text : null,
                hasTrailingIcon && icon
            ]
        })
    });
};
/* harmony default export */ const button_link = ((/* unused pure expression or super */ null && (button_link_ButtonLink)));

;// CONCATENATED MODULE: ./src/components/collection-progress-group/helpers/parse-collection-progress.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


/**
 * Given progress data for a particular collection,
 * and a count of all tutorials in that collection,
 * Return booleans representing collection progress state.
 */ function parse_collection_progress_parseCollectionProgress(progressData, tutorialCount, collection) {
    /**
	 * The basics
	 */ const inProgressTutorialCount = countProgressedRecords(progressData || [], collection.id, TutorialProgressStatus.in_progress);
    const completedTutorialCount = countProgressedRecords(progressData || [], collection.id, TutorialProgressStatus.complete);
    const isCompleted = completedTutorialCount == tutorialCount;
    const isInProgress = inProgressTutorialCount > 0 || completedTutorialCount > 0;
    /**
	 * Return it all
	 */ return {
        completedTutorialCount,
        isCompleted,
        isInProgress,
        tutorialCount
    };
}
/**
 * Given an array of progress records, and a collection.id,
 * Return the count of records that are completed in that collection.
 */ function countProgressedRecords(progressData, collectionId, targetProgress) {
    return progressData.filter((record)=>{
        return record.collection_id == collectionId && progressPercentToStatus(record.complete_percent) == targetProgress;
    }).length;
}
/**
 * Given progress and tutorial data for particular collection,
 * Return a CTA object that links to the "next tutorial" in the collection.
 */ function parse_collection_progress_getNextTutorialCta({ progressData , tutorials , isCompleted , isInProgress , collectionSlug , completedTutorialCount , tutorialCount  }) {
    const targetTutorial = getNextTutorial({
        isCompleted,
        progressData,
        tutorials
    });
    /**
	 * Construct a CTA link from the target tutorial
	 */ const { slug , name  } = targetTutorial;
    const href = getTutorialSlug(slug, collectionSlug);
    if (isCompleted) {
        return {
            href,
            text: "Review",
            ariaLabel: `Review ${name}. All tutorials completed.`
        };
    } else if (isInProgress) {
        return {
            href,
            text: "Continue",
            ariaLabel: `Continue with ${name}. ${completedTutorialCount} out of ${tutorialCount} tutorial${tutorialCount == 1 ? "" : "s"} completed.`
        };
    } else {
        return {
            href,
            text: "Start",
            ariaLabel: `Start with ${name}. ${tutorialCount} tutorial${tutorialCount == 1 ? "" : "s"} in this collection.`
        };
    }
}
/**
 * Given an array of tutorials, and an array of progressData,
 * as well as a progressMatchFn that runs against the matched
 * progressData record for each tutorial (if there is one),
 *
 * Return the first tutorial that meets the progressMatchFn criteria.
 *
 * Note that for tutorials without matched progressData,
 * progressMatchFn() will be called with `undefined`.
 */ function findTutorialByProgress(tutorials, progressData, progressMatchFn) {
    return tutorials.find((tutorial)=>{
        const matchedProgress = progressData.find((record)=>record.tutorial_id == tutorial.id);
        return progressMatchFn(matchedProgress);
    });
}
/**
 * Determine the "next tutorial" in a collection.
 *
 * For in-progress collections, the "next tutorial" is the first tutorial
 * in the collection that does not have "complete" as its progress status.
 *
 * For completed collections, and for all unauthenticated cases,
 * the "next tutorial" is the first tutorial in the collection.
 */ function getNextTutorial({ isCompleted , progressData , tutorials  }) {
    if (isCompleted || !progressData) {
        /**
		 * If we're not authenticated or have no progress,
		 * we'll use the first tutorial.
		 */ return tutorials[0];
    } else {
        /**
		 * If we do have progress data, we look for the first in-progress tutorial.
		 * Note: we may skip tutorials with no progress, and "visited" tutorials,
		 * in order to return the first "in_progress" tutorial.
		 */ const firstInProgressTutorial = findTutorialByProgress(tutorials, progressData, (progress)=>progress && progressPercentToStatus(progress.complete_percent) == TutorialProgressStatus.in_progress);
        if (firstInProgressTutorial) {
            return firstInProgressTutorial;
        }
        /**
		 * If there's no "in_progress" tutorial, we find the first incomplete
		 * tutorial. Note: This could be a tutorial without a progress record,
		 * or it could be a "visited" tutorial.
		 */ const firstIncompleteTutorial = findTutorialByProgress(tutorials, progressData, (progress)=>!progress || progressPercentToStatus(progress.complete_percent) == TutorialProgressStatus.visited);
        if (firstIncompleteTutorial) {
            return firstIncompleteTutorial;
        }
        /**
		 * If there are no incomplete tutorials, then all tutorials are
		 * complete. We return the first tutorial.
		 */ return tutorials[0];
    }
}


;// CONCATENATED MODULE: ./src/components/collection-progress-group/helpers/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/collections-16.tsx
var collections_16 = __webpack_require__(87334);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/check-circle-fill-16.tsx
var check_circle_fill_16 = __webpack_require__(49088);
;// CONCATENATED MODULE: ./src/components/truncate-max-lines/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


function truncate_max_lines_TruncateMaxLines({ children , className , lineHeight , maxLines  }) {
    return /*#__PURE__*/ _jsx("span", {
        className: classNames(s.root, className),
        style: {
            "--max-lines": maxLines,
            "--line-height": lineHeight
        },
        children: children
    });
}
/* harmony default export */ const truncate_max_lines = ((/* unused pure expression or super */ null && (truncate_max_lines_TruncateMaxLines)));

;// CONCATENATED MODULE: ./src/components/card/components/card-description/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



const CardDescription = ({ className , text  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: classNames(s.root, className),
        children: /*#__PURE__*/ _jsx(TruncateMaxLines, {
            className: s.text,
            lineHeight: "var(--token-typography-body-200-line-height)",
            maxLines: 3,
            children: text
        })
    });
};
/* harmony default export */ const card_description = ((/* unused pure expression or super */ null && (CardDescription)));

;// CONCATENATED MODULE: ./src/components/card/components/card-eyebrow/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const CardEyebrow = ({ children , className  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: classNames(s.root, className),
        children: children
    });
};
const card_eyebrow_CardEyebrowText = ({ children  })=>{
    return /*#__PURE__*/ _jsx("span", {
        className: s.text,
        children: children
    });
};

/* harmony default export */ const card_eyebrow = ((/* unused pure expression or super */ null && (CardEyebrow)));

;// CONCATENATED MODULE: ./src/components/card/components/card-footer/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const CardFooter = ({ children , className  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: classNames(s.root, className),
        children: children
    });
};
/* harmony default export */ const card_footer = ((/* unused pure expression or super */ null && (CardFooter)));

;// CONCATENATED MODULE: ./src/components/card/components/card-logo/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


const CardLogo = ({ children , className  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: classNames(s.root, className),
        children: children
    });
};
/* harmony default export */ const card_logo = ((/* unused pure expression or super */ null && (CardLogo)));

;// CONCATENATED MODULE: ./src/components/card/components/card-title/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

const CardTitle = ({ className , text  })=>{
    return /*#__PURE__*/ _jsx("div", {
        className: className,
        children: /*#__PURE__*/ _jsx("span", {
            className: s.text,
            children: text
        })
    });
};
/* harmony default export */ const card_title = ((/* unused pure expression or super */ null && (CardTitle)));

;// CONCATENATED MODULE: ./src/components/card/components/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 






;// CONCATENATED MODULE: ./src/components/progress-bar/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


/**
 * Displays a bar that fills to the percent provided
 * through the `percentDone` prop.
 *
 * `ProgressBar` is always `4px` tall, and grows to fill the width of its
 * parent container. It also accepts an optional `rounded` boolean prop,
 * which defaults to `true`. If `rounded` is set to `false`, the ends of
 * the progress bar will end in sharp corners.
 */ function progress_bar_ProgressBar({ percentDone , rounded =true  }) {
    const safePercentDone = clamp(percentDone, 0, 100);
    return /*#__PURE__*/ _jsx("span", {
        className: s.root,
        style: {
            "--border-radius": rounded ? "2px" : "0px",
            "--portion-done": safePercentDone / 100
        },
        children: /*#__PURE__*/ _jsx("span", {
            className: s.indicator
        })
    });
}
/* harmony default export */ const progress_bar = ((/* unused pure expression or super */ null && (progress_bar_ProgressBar)));

;// CONCATENATED MODULE: ./src/components/collection-progress-group/components/collection-progress-status-section/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 







/**
 * Renders collection progress status, in a nice little box.
 *
 * Without authentication,
 * we show a "Start" CTA which links to the first tutorial in the collection.
 *
 * When authenticated and one or more tutorials in the collection is "complete",
 * we show a "Continue" CTA which links to the next not-"complete" tutorial,
 * as well as a progress bar based on the count of tutorials done.
 *
 * When authenticated and all tutorials in the collection are "complete",
 * we show a "Review" CTA which links to the first tutorial in the collection.
 */ function collection_progress_status_section_CollectionProgressStatusSection({ completedTutorialCount , tutorialCount , isInProgress  }) {
    const { isAuthenticated  } = useAuthentication();
    /**
	 * Completion status
	 */ const isCompleted = completedTutorialCount == tutorialCount;
    const hasProgress = typeof isInProgress == "undefined" ? completedTutorialCount > 0 : isInProgress;
    /**
	 * Status label
	 */ const statusLabel = getStatusLabel({
        completedTutorialCount,
        tutorialCount,
        isInProgress,
        isCompleted
    });
    /**
	 * Status elements
	 */ let statusElements;
    if (isCompleted) {
        statusElements = /*#__PURE__*/ _jsx(CompleteIconAndLabel, {
            statusLabel: statusLabel
        });
    } else if (hasProgress) {
        statusElements = /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                /*#__PURE__*/ _jsx(CountIconAndLabel, {
                    statusLabel: statusLabel
                }),
                /*#__PURE__*/ _jsx(ProgressBar, {
                    percentDone: completedTutorialCount / tutorialCount * 100
                })
            ]
        });
    } else {
        statusElements = /*#__PURE__*/ _jsx(CountIconAndLabel, {
            statusLabel: statusLabel
        });
    }
    /**
	 * Render, with a border and padding.
	 */ return /*#__PURE__*/ _jsx("div", {
        className: classNames(s.statusSectionWithBorder, {
            [s.isAuthenticated]: isAuthenticated
        }),
        children: /*#__PURE__*/ _jsx(StatusSectionElements, {
            children: statusElements
        })
    });
}
/**
 * Get an appropriate status label for the current collection progress
 */ function getStatusLabel({ completedTutorialCount , tutorialCount , isInProgress , isCompleted  }) {
    let statusLabel;
    if (isCompleted) {
        statusLabel = "Complete";
    } else if (isInProgress) {
        statusLabel = `${completedTutorialCount}/${tutorialCount}`;
    } else {
        statusLabel = `${tutorialCount} tutorial${tutorialCount == 1 ? "" : "s"}`;
    }
    return statusLabel;
}
/**
 * Renders CollectionProgress elements, wrapped in a flex container.
 * This positions elements consistently, but does not product padding or border.
 */ function StatusSectionElements({ children  }) {
    return /*#__PURE__*/ _jsxs("div", {
        className: s.statusSectionElements,
        children: [
            children,
            " "
        ]
    });
}
/**
 * Displays a green check icon, and a "complete" label.
 * Label text is set through `statusLabel`.
 */ function CompleteIconAndLabel({ statusLabel  }) {
    return /*#__PURE__*/ _jsxs("div", {
        className: s.completeIconAndLabel,
        children: [
            /*#__PURE__*/ _jsx(CompleteIcon, {}),
            /*#__PURE__*/ _jsx(CardEyebrowText, {
                children: statusLabel
            })
        ]
    });
}
/**
 * Displays a circle check icon, styled for composition in CollectionProgress
 */ function CompleteIcon() {
    return /*#__PURE__*/ _jsx(IconCheckCircleFill16, {
        className: s.completeIcon
    });
}
/**
 * Displays a "collection" icon, and "X/Y tutorials" label.
 * Label text is set through `statusLabel`.
 */ function CountIconAndLabel({ statusLabel  }) {
    return /*#__PURE__*/ _jsxs("div", {
        className: s.countIconAndLabel,
        children: [
            /*#__PURE__*/ _jsx(CountIcon, {}),
            /*#__PURE__*/ _jsx(CardEyebrowText, {
                children: statusLabel
            })
        ]
    });
}
/**
 * Displays a collections icon, styled for composition in CollectionProgress
 */ function CountIcon() {
    return /*#__PURE__*/ _jsx(IconCollections16, {
        className: s.countIcon
    });
}

/* harmony default export */ const collection_progress_status_section = ((/* unused pure expression or super */ null && (collection_progress_status_section_CollectionProgressStatusSection)));

;// CONCATENATED MODULE: ./src/components/collection-progress-group/components/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

;// CONCATENATED MODULE: ./src/components/collection-progress-group/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 






/**
 * Displays collection progress status and CTA.
 */ function CollectionProgressGroup({ collection  }) {
    const { id , slug , tutorials  } = collection;
    /**
	 * Get collection progress, which affects the
	 * CTA bar we display for the collection.
	 */ const { data: progressData  } = useCollectionProgress({
        collectionId: id
    });
    /**
	 * Parse the progress-related information we need from the progress records,
	 * current collection slug, and list of tutorials in this collection.
	 */ const { completedTutorialCount , isCompleted , isInProgress , tutorialCount  } = useMemo(()=>parseCollectionProgress(progressData, tutorials.length, {
            id,
            slug
        }), [
        progressData,
        tutorials,
        id,
        slug
    ]);
    /**
	 * Parse the CTA we want to show for the "next" tutorial in the collection.
	 * This "next" tutorial varies based on the progress state
	 */ const tutorialCta = useMemo(()=>getNextTutorialCta({
            progressData,
            tutorials,
            isCompleted,
            isInProgress,
            completedTutorialCount,
            tutorialCount,
            collectionSlug: slug
        }), [
        completedTutorialCount,
        isCompleted,
        isInProgress,
        progressData,
        slug,
        tutorialCount,
        tutorials
    ]);
    return /*#__PURE__*/ _jsxs("div", {
        className: s.root,
        children: [
            /*#__PURE__*/ _jsx(ButtonLink, {
                "aria-label": tutorialCta.ariaLabel,
                href: tutorialCta.href,
                text: tutorialCta.text
            }),
            /*#__PURE__*/ _jsx(CollectionProgressStatusSection, {
                completedTutorialCount: completedTutorialCount,
                tutorialCount: tutorialCount,
                isInProgress: isInProgress
            })
        ]
    });
}
/**
 * Note: ButtonLink is exported here so that Swingset can work.
 * We can use peerComponents for Swingset, but this doesn't make
 * the component available in LiveComponent, which is a spot where
 * we want it.
 */ 
/* harmony default export */ const collection_progress_group = ((/* unused pure expression or super */ null && (CollectionProgressGroup)));

// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/check-circle-16.tsx
var check_circle_16 = __webpack_require__(43213);
// EXTERNAL MODULE: ./node_modules/@hashicorp/flight-icons/svg-react/circle-half-16.tsx
var circle_half_16 = __webpack_require__(98859);
;// CONCATENATED MODULE: ./src/components/tutorial-progress-icon/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




function tutorial_progress_icon_TutorialProgressIcon({ status , size =12 , isActive  }) {
    const className = classNames(s.progressIcon, s[`size_${size}`], s[`status_${status}`], {
        [s.isActive]: isActive
    });
    if (status == "complete") {
        return /*#__PURE__*/ _jsx(IconCheckCircle16, {
            className: className
        });
    } else if (status == "in_progress") {
        return /*#__PURE__*/ _jsx(IconCircleHalf16, {
            className: className
        });
    } else {
        return null;
    }
}
/* harmony default export */ const tutorial_progress_icon = ((/* unused pure expression or super */ null && (tutorial_progress_icon_TutorialProgressIcon)));

;// CONCATENATED MODULE: ./src/components/tutorials-sidebar/components/tutorial-view-sidebar-content/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

// Hooks


// Components




// Styles

/**
 * Renders sidebar content for tutorial views.
 */ function TutorialViewSidebarContent({ collection , items  }) {
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(CollectionProgress, {
                collection: collection
            }),
            /*#__PURE__*/ _jsx(SectionList, {
                children: items.map((item)=>{
                    return /*#__PURE__*/ _jsx(TutorialListItem, {
                        text: item.text,
                        href: item.href,
                        isActive: item.isActive,
                        tutorialId: item.tutorialId,
                        collectionId: item.collectionId
                    }, `${item.collectionId}${item.tutorialId}`);
                })
            })
        ]
    });
}
/**
 * Displays collection progress status.
 */ function CollectionProgress({ collection  }) {
    const { id , slug , tutorials  } = collection;
    /**
	 * Get collection progress, which affects the
	 * CTA bar we display for the collection.
	 */ const { data: progressData  } = useCollectionProgress({
        collectionId: id
    });
    /**
	 * Parse the progress-related information we need from the progress records,
	 * current collection slug, and list of tutorials in this collection.
	 */ const { completedTutorialCount , tutorialCount , isInProgress  } = useMemo(()=>parseCollectionProgress(progressData, tutorials.length, {
            id,
            slug
        }), [
        progressData,
        tutorials,
        id,
        slug
    ]);
    return /*#__PURE__*/ _jsx("div", {
        className: s.collectionProgressContainer,
        children: /*#__PURE__*/ _jsx(CollectionProgressStatusSection, {
            completedTutorialCount: completedTutorialCount,
            tutorialCount: tutorialCount,
            isInProgress: isInProgress
        })
    });
}
/**
 * Renders a tutorial nav menu item, which is a menu item with
 * an optional progress status indicator for authenticated users.
 */ function TutorialListItem({ href , isActive , text , tutorialId , collectionId  }) {
    /**
	 * Query for progress, and display the appropriate status icon
	 */ const { tutorialProgressStatus  } = useTutorialProgress({
        tutorialId,
        collectionId
    });
    const trailingIcon = /*#__PURE__*/ _jsx(TutorialProgressIcon, {
        status: tutorialProgressStatus,
        isActive: isActive
    });
    return /*#__PURE__*/ _jsx(SidebarNavMenuItem, {
        item: {
            isActive,
            title: text,
            href,
            trailingIcon
        }
    });
}
/* harmony default export */ const tutorial_view_sidebar_content = ((/* unused pure expression or super */ null && (TutorialViewSidebarContent)));

;// CONCATENATED MODULE: ./src/components/tutorials-sidebar/index.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 






function TutorialsSidebar({ backToLinkProps , children , levelButtonProps , overviewItemHref , title , visuallyHideTitle  }) {
    return /*#__PURE__*/ _jsx(Sidebar, {
        backToLinkProps: backToLinkProps,
        levelButtonProps: levelButtonProps,
        overviewItemHref: overviewItemHref,
        showFilterInput: false,
        title: title,
        visuallyHideTitle: visuallyHideTitle,
        children: children
    });
}
function tutorials_sidebar_CollectionViewSidebarContent({ sections , productSlug  }) {
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(TutorialsOverviewItem, {
                productSlug: productSlug
            }),
            sections?.map(({ title , items  })=>{
                return /*#__PURE__*/ _jsxs(Fragment, {
                    children: [
                        /*#__PURE__*/ _jsx(HorizontalRule, {}),
                        title ? /*#__PURE__*/ _jsx(SectionTitle, {
                            text: title
                        }) : null,
                        /*#__PURE__*/ _jsx(tutorials_sidebar_SectionList, {
                            children: items.map(({ text , href , isActive , badge  })=>{
                                return /*#__PURE__*/ _jsx(ListItem, {
                                    text: text,
                                    href: href,
                                    isActive: isActive,
                                    badge: badge
                                }, `${text}${href}`);
                            })
                        })
                    ]
                }, title);
            })
        ]
    });
}
function TutorialsOverviewItem({ productSlug  }) {
    const router = useRouter();
    const overviewItemHref = `/${productSlug}/tutorials`;
    return /*#__PURE__*/ _jsx(SidebarNavHighlightItem, {
        text: "Tutorials",
        href: overviewItemHref,
        theme: productSlug,
        isActive: router.asPath === overviewItemHref
    });
}
function tutorials_sidebar_SectionList({ children  }) {
    return /*#__PURE__*/ _jsx("ul", {
        className: s.listRoot,
        children: children
    });
}
function ListItem({ href , isActive , text , badge  }) {
    return /*#__PURE__*/ _jsx(SidebarNavMenuItem, {
        item: {
            isActive,
            title: text,
            href,
            badge
        }
    });
}
function SectionTitle({ text  }) {
    return /*#__PURE__*/ _jsx(SidebarSectionHeading, {
        text: text
    });
}
function HorizontalRule() {
    return /*#__PURE__*/ _jsx(SidebarHorizontalRule, {});
}

/* harmony default export */ const tutorials_sidebar = ((/* unused pure expression or super */ null && (TutorialsSidebar)));

;// CONCATENATED MODULE: ./src/views/collection-view/helpers/generate-collection-sidebar-nav-data.tsx
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 * Generate the Tutorials Collection sidebar nav data level.
 * This is used both on the Collection view,
 * and in the mobile menu on the individual Tutorials view
 */ function generateCollectionSidebarNavData(product, sidebarSections) {
    return {
        levelButtonProps: {
            levelUpButtonText: `${product.name} Home`,
            levelDownButtonText: "Previous"
        },
        backToLinkProps: {
            text: `${product.name} Home`,
            href: `/${product.slug}`
        },
        title: "Tutorials",
        /* We always visually hide the title, as we've added in a
			"highlight" item that would make showing the title redundant. */ visuallyHideTitle: true,
        children: /*#__PURE__*/ _jsx(CollectionViewSidebarContent, {
            productSlug: product.slug,
            sections: sidebarSections
        })
    };
}

;// CONCATENATED MODULE: ./src/views/collection-view/helpers/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(71017);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);
;// CONCATENATED MODULE: external "validator/lib/isUUID"
const isUUID_namespaceObject = require("validator/lib/isUUID");
;// CONCATENATED MODULE: ./src/lib/learn-client/api/utils/fetch-all.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 

/**
 *  Based off content-sync imp --> https://github.com/hashicorp/learn-api-content-sync/blob/main/util/api-client.js#L77
 *
 *  By detault, this function will recursively fetch all tutorials or collections from the db
 *  If you don't want all the tutorials, pass `recurse: false` and a specified limit.
 *  The baseUrl option specifies which endpoint (either collections or tutorials) to hit
 **/ const MAX_LIMIT = "100" // Defaults to API max
;
async function fetchAll({ baseUrl , recurse =true , limit =MAX_LIMIT , fullContent =false , after , fetchedTutorials  }) {
    // Set the base array if it's the first call
    if (typeof fetchedTutorials === "undefined") {
        fetchedTutorials = [];
    }
    const response = await fetchTutorialsOrCollections(baseUrl, limit, after, fullContent);
    if (response.ok) {
        const data = await response.json();
        const allTutorials = [
            ...fetchedTutorials,
            ...data.result
        ];
        /*
		 ** If recurse is false, we only want the # of tuts specific by the limit.
		 ** If there's less than 100 tutorials fetched (less than the max limit),
		 ** that means that we've fetched everything.
		 */ if (!recurse || data.result.length < Number(MAX_LIMIT)) {
            return allTutorials;
        }
        // Otherwise, recurse to get the next batch of tutorials
        return fetchAll({
            baseUrl,
            recurse: true,
            limit,
            // The last ID
            after: data.result[data.result.length - 1].id,
            // Pass the accumulated tutorials
            fetchedTutorials: allTutorials,
            fullContent
        });
    }
}
async function fetchTutorialsOrCollections(baseRoute, limit, after, full) {
    const params = new URLSearchParams({
        limit
    });
    if (after) {
        params.append("after", after);
    }
    if (full) {
        params.append("full", "1");
    }
    const queryStr = `?${params.toString()}`;
    const route = external_path_default().join(baseRoute, queryStr);
    const response = await learn_client_get(route);
    if (response.ok) {
        return response;
    }
    const error = await learn_client_toError(response);
    throw error;
}

;// CONCATENATED MODULE: ./src/lib/learn-client/api/utils/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
function formatSlug(slug) {
    return slug.replace("/", "|");
}
// if the identifier is a slug, we need to format for the request to replace slashes (/) with pipes (|)
function utils_formatIdentifier(idOrSlug) {
    let identifier = idOrSlug;
    if (!isUuid(identifier)) {
        identifier = formatSlug(idOrSlug);
    }
    return identifier;
}
function utils_formatBatchQueryStr(idsOrSlugs, withContent) {
    const params = new URLSearchParams();
    const identifiers = idsOrSlugs.toString();
    if (idsOrSlugs.length > 0) {
        // Assuming here that if the first item in the array is a uuid, they are all uuids
        if (isUuid(idsOrSlugs[0])) {
            params.append("ids", identifiers);
        } else {
            params.append("slugs", identifiers);
        }
    }
    if (withContent) {
        params.append("full", "1");
    }
    return `?${params.toString()}`;
}
// Barrel exports. This function can be imported from /utils


;// CONCATENATED MODULE: ./src/lib/learn-client/api/collection/formatting.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
function formatCollection(collection) {
    const { id , slug , name , short_name , description , icon , theme , ordered , level , category , tutorials  } = collection;
    return {
        id,
        slug,
        name,
        shortName: short_name,
        description,
        icon,
        theme,
        ordered,
        level,
        category: category || undefined,
        tutorials: tutorials.map(formatToTutorialLite)
    };
}
function formatToTutorialLite(item) {
    const { id , name , slug , description , read_time , edition , products_used , default_collection  } = item.tutorial;
    const productsUsed = products_used.map(formatProductUsed);
    const video = formatVideo(item.tutorial);
    const handsOnLab = formatHandsOnLab(item.tutorial);
    return {
        id,
        name,
        slug,
        description,
        readTime: read_time,
        edition: edition,
        productsUsed,
        video,
        handsOnLab,
        defaultContext: formatToCollectionLite(default_collection)
    };
}
function formatProductUsed(productUsed) {
    const { product , tutorial_id , is_primary , is_beta , min_version , max_version  } = productUsed;
    const { id , slug , name , docs_url , description  } = product;
    return {
        product: {
            id,
            slug,
            name,
            docsUrl: docs_url,
            description
        },
        tutorial: tutorial_id,
        isPrimary: is_primary,
        isBeta: is_beta,
        minVersion: min_version || undefined,
        maxVersion: max_version || undefined
    };
}

;// CONCATENATED MODULE: ./src/lib/learn-client/api/tutorial/formatting.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 
/**
 * This function handles two types of return tutorial data from the API.
 * For getTutorials and getAllTutorials, the API returns CollectionLite
 * for featured_collections. But with getTutorial, we need featured_collections
 * to be the full Collection type (with tutorials).
 *
 * This function returns either:
 * - Tutorial, with featuredCollections: CollectionLite
 * - or TutorialFullCollectionCtx, with featuredCollections: Collection
 */ function formatting_formatTutorialData(tutorial) {
    const { id , slug , name , description , content , default_collection_id , featured_collections , read_time , edition , products_used , variants  } = tutorial;
    const productsUsed = products_used.map(formatProductUsed);
    const video = formatVideo(tutorial);
    const handsOnLab = formatHandsOnLab(tutorial);
    const collectionCtx = formatCollectionCtx(featured_collections, default_collection_id);
    // We only accept a single variant currently, so we take the first array item
    // The learn-api-content-sync should prevent multiple variants from syncing into
    // the database, this is an extra protection
    const formattedVariant = variants?.length > 0 ? formatVariant(variants[0]) : undefined;
    return {
        id,
        slug,
        name,
        description,
        content,
        collectionCtx,
        productsUsed,
        readTime: read_time,
        video,
        handsOnLab,
        edition: edition,
        variant: formattedVariant
    };
}
function formatToCollectionLite(collection) {
    const { id , name , slug , short_name , level , theme  } = collection;
    return {
        id,
        name,
        slug,
        shortName: short_name,
        level,
        theme
    };
}
function formatCollectionCtx(featuredCollections, defaultCollectionId) {
    let featuredIn;
    const defaultCollection = featuredCollections.find(({ id  })=>id === defaultCollectionId);
    // assuming if the first collection has tutorials, were dealing with full Collection
    if ("tutorials" in featuredCollections[0]) {
        featuredIn = featuredCollections.map(formatCollection);
    } else {
        featuredIn = featuredCollections.map(formatToCollectionLite);
    }
    const collectionCtx = {
        default: formatToCollectionLite(defaultCollection),
        featuredIn
    };
    return collectionCtx;
}
function formatVideo({ video_id , video_host , video_inline  }) {
    let video = undefined;
    if (video_id) {
        video = {
            id: video_id,
            videoHost: video_host,
            videoInline: video_inline
        };
    }
    return video;
}
function formatHandsOnLab({ hands_on_lab_id , hands_on_lab_provider  }) {
    let handsOnLab = undefined;
    if (hands_on_lab_id) {
        handsOnLab = {
            id: hands_on_lab_id,
            provider: hands_on_lab_provider
        };
    }
    return handsOnLab;
}
function formatVariant(variant) {
    const { options , ...rest } = variant;
    return {
        ...rest,
        options: options.map(({ display_order , ...rest })=>({
                displayOrder: display_order,
                ...rest
            }))
    };
}

;// CONCATENATED MODULE: ./src/lib/learn-client/api/tutorial/augment-tutorial.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 



// Featured Collections are augmented to the base tutorial
async function augment_tutorial_augmentTutorial(tutorial) {
    const featured_collections = await getFeaturedCollections(tutorial.id);
    const tutorialClone = Object.assign({}, tutorial);
    delete tutorialClone.featured_collections;
    return {
        ...tutorialClone,
        featured_collections
    };
}
// featured collections are accessed via another route
async function getFeaturedCollections(idOrSlug) {
    const identifier = formatIdentifier(idOrSlug);
    // /tutorials/:id/collections
    const route = path.join(TUTORIAL_API_ROUTE, `${identifier}/collections`);
    const featuredCollectionsRes = await get(route);
    if (featuredCollectionsRes.ok) {
        const res = await featuredCollectionsRes.json();
        return res.result;
    }
    const error = await toError(featuredCollectionsRes);
    throw error;
}

;// CONCATENATED MODULE: ./src/lib/learn-client/api/tutorial/index.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 




const tutorial_TUTORIAL_API_ROUTE = "/tutorials";
async function getTutorial(idOrSlug) {
    const identifier = formatIdentifier(idOrSlug);
    // /tutorials/:id
    const route = path.join(tutorial_TUTORIAL_API_ROUTE, identifier);
    const getTutorialRes = await get(route);
    if (getTutorialRes.ok) {
        const res = await getTutorialRes.json();
        const augmentedData = await augmentTutorial(res.result) // additional Api call here
        ;
        return formatTutorialData(augmentedData);
    }
    // This is handled by tutorial template /pages/tutorials/[...slug] to render 404 page
    if (getTutorialRes.status === 404) {
        console.error("Learn Api Client: 404 — Tutorial not found");
        return null;
    }
    const error = await toError(getTutorialRes);
    throw error;
}
async function getTutorials(idsOrSlugs, withContent) {
    const queryStr = formatBatchQueryStr(idsOrSlugs, withContent);
    const route = path.join(tutorial_TUTORIAL_API_ROUTE, queryStr);
    const getTutorialsRes = await get(route);
    if (getTutorialsRes.ok) {
        const res = await getTutorialsRes.json();
        return res.result.map(formatTutorialData);
    }
    const error = await toError(getTutorialsRes);
    throw error;
}
// getAllTutorials
// if a limit is not passed, all tutorials are fetched
async function getAllTutorials(options) {
    let result = [];
    const limit = options?.limit?.toString();
    const recurse = Boolean(!limit);
    // errors handled by the `fetchAll` function
    const allTutorials = await fetchAll({
        baseUrl: tutorial_TUTORIAL_API_ROUTE,
        recurse,
        limit,
        fullContent: options?.fullContent
    });
    if (options?.slugsOnly) {
        result = allTutorials.map(({ slug , default_collection  })=>({
                slug,
                collection_slug: default_collection.slug
            }));
    } else {
        return allTutorials.map(formatting_formatTutorialData);
    }
    return result;
}

;// CONCATENATED MODULE: ./src/pages/api/tutorials-map.ts
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ 


// 1 hour
const MAP_MAX_AGE_IN_SECONDS = 60 * 60 * 60;
/**
 * This API caches a tutorial-map blob for the tutorial rewrites
 * remark plugin - lib/remark-plugins/rewrite-tutorial-links.
 * This ensures that calls to `getAllTutorials` are limited
 * for ISR generated tutorial views
 */ async function tutorialsMapHandler(req, res) {
    try {
        const mapData = await generateTutorialMap();
        if (Object.keys(mapData).length > 0) {
            res.setHeader("cache-control", `s-maxage=${MAP_MAX_AGE_IN_SECONDS}`);
            res.status(external_http_status_codes_.StatusCodes.OK).json(mapData);
        } else {
            res.status(external_http_status_codes_.StatusCodes.BAD_REQUEST).json({
                message: "Failed to generate tutorial map"
            });
        }
    } catch (e) {
        res.status(external_http_status_codes_.StatusCodes.INTERNAL_SERVER_ERROR).json({
            message: "Server error: unable to generate tutorial map"
        });
    }
}
/**
 * This function creates a map of 'database-slug': 'dev-dot/path'
 */ async function generateTutorialMap() {
    const allTutorials = await getAllTutorials({
        fullContent: false,
        slugsOnly: true
    });
    const mapItems = allTutorials.map((t)=>{
        const oldPath = t.slug;
        const newPath = get_slug_getTutorialSlug(t.slug, t.collection_slug);
        return [
            oldPath,
            newPath
        ];
    });
    return Object.fromEntries(mapItems);
}


/***/ }),

/***/ 84324:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": () => (/* binding */ AuthErrors),
/* harmony export */   "I": () => (/* binding */ ValidAuthProviderId)
/* harmony export */ });
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */ var ValidAuthProviderId;
(function(ValidAuthProviderId) {
    ValidAuthProviderId["CloudIdp"] = "cloud-idp";
})(ValidAuthProviderId || (ValidAuthProviderId = {}));
var AuthErrors;
(function(AuthErrors) {
    AuthErrors[// NOTE: temporary prefix of [next-auth] for existing log monitor
    // TODO: abstract logging so everything is grouped
    "RefreshAccessTokenError"] = "[next-auth] RefreshAccessTokenError";
    AuthErrors["RefreshAccessTokenExpiredError"] = "[next-auth] RefreshAccessTokenError: token_inactive";
})(AuthErrors || (AuthErrors = {}));


/***/ }),

/***/ 62310:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"title":"Terraform Registry","href":"https://registry.terraform.io/"}]');

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [3250], () => (__webpack_exec__(22318)));
module.exports = __webpack_exports__;

})();